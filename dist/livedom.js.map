{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/DataManager.ts","src/Directive.ts","src/DirectiveElementEach.ts","src/DirectiveElementElse.ts","src/DirectiveElementIf.ts","src/DirectiveElementRender.ts","src/DomScanner.ts","src/DomScannerLoaded.ts","src/LiveDom.ts","src/Page.ts","src/PageController.ts","src/Parser.ts","src/main.ts"],"names":["f","exports","module","define","amd","window","global","self","this","LiveDom","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","DataManager","initData","pageData","Object","create","scopeDataStack","data","prototype","mergePageData","assign","pushScopeData","scopeData","push","popScopeData","pop","getPrototypeOf","Directive","controller","hasDirective","_info","info","directives","Array","isArray","_i","_a","_super","Directive_1","propLiveKeyData","Symbol","DirectiveElementEach","__extends","element","config","attrs","attr","attrInfo","removeAttribute","render","continueRender","elementInfo","items","exec","dataManager","renderElements","l","item","keyVal","itemElement","exists","find","ele","indexOf","this_1","cloneNode","index","itemRenderElements","_this","DirectiveElementEach_1","DirectiveElementIf_1","DirectiveElementElse","hasAttribute","prevNode","previousSibling","isPlaceholder","prevNodeInfo","getNodeInfo","DirectiveElementIf","nodeType","DirectiveElementRender","attrName","attrVal","setAttribute","renderChildNodes","DomScanner","doc","options","ignoreElementTags","script","style","observer","MutationObserver","mutationObserverCallback","bind","mutationList","DomScanner_1","DomScannerLoaded","scan","scanPromise","Promise","resolve","reject","readyState","walkNode","documentElement","observe","subtree","childList","attributes","characterData","addEventListener","node","processElement","processText","processComment","tagName","toLowerCase","processElementStart","childNodes","forEach","processElementEnd","elementStart","elementEnd","comment","text","apply","arguments","Page_1","PageController_1","initPage","PageController","document","createPage","page","Page","updateData","updatePageData","DomScannerLoaded_1","DirectiveElementRender_1","DataManager_1","Parser_1","DirectiveElementElse_1","propLiveInfo","nextId","scanCompletedPromise","requestRenderPagePromise","elementDirectivesConfig","scanner","scanElementStart","scanElementEnd","scanComment","scanText","then","loaded","requestRenderPage","removeNode","parentNode","removeChild","insertAfter","before","nextSibling","insertBefore","appendChild","renderElement","setupElement","setupText","id","placeholderComment","setupAttribute","name","setupElementDirectives","keys","setNodeInfo","directive","parseResult","Parser","parseText","value","hasTextExpress","placeholder","nextNode","processElementDirectiveRender","getPlaceholderComment","exists_1","prev","renderElements_1","_b","exists_2","renderInfo","directiveIndex","createComment","nodes","_t","src","des","cloneNodesInfo","srcNodes","desNodes","hasNodeInfo","isLiveNode","expressionRegex","parts","match","lastIndex","substring","names","split","lastNamePath","namesPath","map","body","concat","join","Function","buildTextFunction","results","parts_1","text_1","buildParseResultRenderer","result","LiveDom_1","default"],"mappings":"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","file":"livedom.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\r\nexport type TypeData = {[k: string]: any};\r\n\r\nexport class DataManager\r\n{\r\n    public data: TypeData;\r\n    public initData: TypeData;\r\n    public pageData: TypeData;\r\n    // public mergeData: TypeData;\r\n    private scopeDataStack: TypeData[];\r\n\r\n    public constructor(initData: TypeData)\r\n    {\r\n        this.initData = initData;\r\n        this.pageData = Object.create(this.initData);\r\n\r\n        this.scopeDataStack = [];\r\n\r\n        this.data = Object.create(this.pageData);\r\n    }\r\n\r\n    public mergePageData(pageData: TypeData)\r\n    {\r\n        Object.assign(this.pageData, pageData);\r\n    }\r\n\r\n    public pushScopeData(scopeData: TypeData)\r\n    {\r\n        this.scopeDataStack.push(scopeData);\r\n        this.data = Object.create(this.data);\r\n        Object.assign(this.data, scopeData);\r\n    }\r\n    public popScopeData(scopeData: TypeData)\r\n    {\r\n        if (this.scopeDataStack[this.scopeDataStack.length - 1] != scopeData)\r\n            throw new Error(\"popScopeData fail! scopeData not last data.\");\r\n\r\n        this.scopeDataStack.pop();\r\n        this.data = Object.getPrototypeOf(this.data);\r\n    }\r\n}\r\n","import { PageController } from \"./PageController\";\r\nimport { ElementRenderInfo, NodeElementInfo, NodeInfo } from \"./NodeInfo\";\r\n\r\nexport interface DirectiveConfig<N extends Node = Node>\r\n{\r\n    attr?: string;\r\n    create: (controller: PageController, node: N, info: NodeInfo, config: DirectiveConfig<N>)=>Directive<N>|null;\r\n}\r\n\r\nexport interface DirectiveRender<N extends Node = Node>\r\n{\r\n    (element: N, renderInfo: ElementRenderInfo): N[];\r\n}\r\n// class DirectiveText extends Directive\r\n// {\r\n// }\r\n\r\n\r\nexport abstract class Directive<N extends Node = Node>\r\n{\r\n    public static hasDirective(_info: NodeInfo) : boolean\r\n    {\r\n        const info = _info as NodeElementInfo;\r\n        \r\n        if(!info.directives || !Array.isArray(info.directives))\r\n            return false;\r\n        \r\n        for(const d of info.directives)\r\n        {\r\n            if(d instanceof this)\r\n                return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    // public name: string = null;\r\n    // public abstract buildNode(nodeInfo: NodeInfo, node: Node);\r\n    public abstract render(element: N, renderInfo: ElementRenderInfo, continueRender: DirectiveRender<N>): N[];\r\n    // public abstract unsetNode(nodeInfo: NodeInfo);\r\n    protected controller: PageController;\r\n    protected constructor(controller: PageController)\r\n    {\r\n        this.controller = controller;\r\n    }\r\n}\r\n\r\n// class DirectiveElementStateClass extends Directive //live-state=\"rendering|complete\"\r\n// {\r\n// }\r\n// class DirectiveElementContent extends Directive //live:cont\r\n// {\r\n// }\r\n\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nconst propLiveKeyData = Symbol(\"LiveDomKeyDataProp\");\r\n\r\nexport class DirectiveElementEach extends Directive\r\n{\r\n    public static create(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig): DirectiveElementEach\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return null;\r\n\r\n        const attrInfo = info.attrs[config.attr];\r\n\r\n        element.removeAttribute(config.attr);\r\n        delete info.attrs[config.attr];\r\n\r\n        return new DirectiveElementEach(controller, element, attrInfo);\r\n    }\r\n\r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n\r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n\r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        const elementInfo = info.elementInfo;\r\n        // const directiveAttrInfo = elementInfo.directiveAttrs[attrLiveEach];\r\n        const items = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        // info.directivesVal[attrLiveEach] = items;\r\n        \r\n        if(!Array.isArray(items) || items.length == 0)\r\n            return [];\r\n        \r\n        let renderElements: Element[] = [];\r\n        for(let i=0, l=items.length; i<l; ++i)\r\n        {\r\n            const item = items[i];\r\n            // console.log(\"DirectiveElementEach item:\", item);\r\n            const keyVal = item; //TODO keyGetter(item), default return item\r\n            \r\n            // console.log(\"processElementEach itemElement from exists: \", info.exists.find((ele: Element) => ele[propLiveKeyData]==keyVal && renderElements.indexOf(ele)<0));\r\n            // const itemElement = this.controller.cloneNode(elementInfo.element);\r\n            const itemElement = info.exists.find((ele: Element) => propLiveKeyData in ele && ele[propLiveKeyData] == keyVal && renderElements.indexOf(ele) < 0) as Element ||\r\n                                this.controller.cloneNode(elementInfo.element);\r\n            itemElement[propLiveKeyData] = keyVal;\r\n            \r\n            const scopeData = { item, index: i };\r\n            this.controller.dataManager.pushScopeData(scopeData);\r\n            const itemRenderElements = continueRender(itemElement, info);\r\n            this.controller.dataManager.popScopeData(scopeData);\r\n            \r\n            if (itemRenderElements.length > 0)\r\n                renderElements.push(itemRenderElements[0]);\r\n        }\r\n\r\n        return renderElements;\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { DirectiveElementEach } from \"./DirectiveElementEach\";\r\nimport { DirectiveElementIf } from \"./DirectiveElementIf\";\r\nimport { NodeElementInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementElse extends Directive\r\n{\r\n    public static create(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig): DirectiveElementElse\r\n    {\r\n        if (!element.hasAttribute(config.attr))\r\n            return null;\r\n        \r\n        element.removeAttribute(config.attr);\r\n        \r\n        return new DirectiveElementElse(controller, element);\r\n    }\r\n    \r\n    // private element: Element;\r\n    protected constructor(controller: PageController, element: Element)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementElse renderNode:\", element, element.previousElementSibling, info);\r\n        let prevNode: Node = info.exists[0];\r\n        while(prevNode = prevNode.previousSibling)\r\n        {\r\n            if(this.controller.isPlaceholder(prevNode))\r\n            {\r\n                const prevNodeInfo = this.controller.getNodeInfo(prevNode);\r\n                if(DirectiveElementIf.hasDirective(prevNodeInfo) || DirectiveElementEach.hasDirective(prevNodeInfo))\r\n                    return continueRender(element, info);\r\n                \r\n                break;\r\n            }\r\n            \r\n            if(prevNode.nodeType == 1) //1: Node.ELEMENT_NODE\r\n                break;\r\n        }\r\n        \r\n        return [];\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementIf extends Directive\r\n{\r\n    public static create(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig): DirectiveElementIf\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return null;\r\n\r\n        const attrInfo = info.attrs[config.attr];\r\n\r\n        element.removeAttribute(config.attr);\r\n        delete info.attrs[config.attr];\r\n\r\n        return new DirectiveElementIf(controller, element, attrInfo);\r\n    }\r\n\r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n\r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n\r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        const elementInfo = info.elementInfo;\r\n        // const directiveAttrInfo = elementInfo.directiveAttrs[attrLiveEach];\r\n        const val = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        if (val)\r\n            return continueRender(element, info);\r\n\r\n        return [];\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementRender extends Directive\r\n{\r\n    public static create(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig): DirectiveElementRender\r\n    {\r\n        return new DirectiveElementRender(controller);\r\n    }\r\n\r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementRender renderNode:\", element, info);\r\n        const elementInfo = info.elementInfo;\r\n\r\n        for (const attrName in elementInfo.attrs)\r\n        {\r\n            // if has custom element and xxxxx()\r\n            // else if attrVal != attr.value\r\n            const attrInfo = elementInfo.attrs[attrName];\r\n            const attrVal = attrInfo.exec(this.controller.dataManager.data);\r\n            // renderInfo.attrsVal[attrName] = attrVal;\r\n            element.setAttribute(attrName, attrVal);\r\n        }\r\n\r\n        this.controller.renderChildNodes(element);\r\n\r\n        return continueRender(element, info);\r\n    }\r\n}\r\n","\r\n\r\nexport interface DomScannerOptions\r\n{\r\n    elementStart(element: Element): void;\r\n    elementEnd(element: Element): void;\r\n    comment(comment: Comment): void;\r\n    text(text: Text): void;\r\n}\r\n\r\nexport abstract class DomScanner\r\n{\r\n    protected doc: Document;\r\n    protected observer: MutationObserver;\r\n    protected options: DomScannerOptions;\r\n    protected ignoreElementTags = {script: true, style: true};\r\n\r\n    public constructor(doc: Document, options: DomScannerOptions)\r\n    {\r\n        this.options = options;\r\n        this.doc = doc;\r\n        this.observer = new MutationObserver(this.mutationObserverCallback.bind(this));\r\n    }\r\n\r\n    public abstract scan(): Promise<void>;\r\n\r\n    private mutationObserverCallback(mutationList: MutationRecord[])\r\n    {\r\n        // console.log(\"mutationObserverCallback:\", mutationList);\r\n        // push into loading queue\r\n    }\r\n}\r\n","import { DomScanner } from \"./DomScanner\";\r\n\r\nexport class DomScannerLoaded extends DomScanner\r\n{\r\n    protected scanPromise: Promise<void> = null;\r\n\r\n    public scan(): Promise<void>\r\n    {\r\n        if (this.scanPromise)\r\n            return this.scanPromise;\r\n\r\n        return this.scanPromise = new Promise<void>((resolve, reject) =>\r\n        {\r\n            if (this.doc.readyState == \"complete\")\r\n            {\r\n                this.walkNode(this.doc.documentElement);\r\n                this.observer.observe(this.doc.documentElement, { subtree: true, childList: true, attributes: true, characterData: true });\r\n                resolve();\r\n            }\r\n\r\n            else\r\n            {\r\n                this.doc.addEventListener(\"DOMContentLoaded\", () =>\r\n                {\r\n                    this.walkNode(this.doc.documentElement);\r\n                    this.observer.observe(this.doc.documentElement, { subtree: true, childList: true, attributes: true, characterData: true });\r\n                    resolve();\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    protected walkNode(node: Node)\r\n    {\r\n        // console.log(\"walk node:\", node, this.isCompletedNode(node));\r\n        switch (node.nodeType)\r\n        {\r\n            case 1: //ELEMENT_NODE\r\n                this.processElement(node as Element);\r\n                break;\r\n            case 3: //TEXT_NODE\r\n                this.processText(node as Text);\r\n                break;\r\n            // case 4: //CDATA_SECTION_NODE\r\n            //     if(childInfo = initText(controller, node as Text))\r\n            //     {\r\n            //         info.watch = info.watch.concat(childInfo.watch);\r\n            //     }\r\n            //     break;\r\n            case 8: //COMMENT_NODE\r\n                this.processComment(node as Comment);\r\n                break;\r\n            // default : //Not support type\r\n            //     break;\r\n        }\r\n\r\n    }\r\n\r\n    protected processElement(element: Element)\r\n    {\r\n        // console.log(\"process element:\", element);\r\n        if (this.ignoreElementTags[element.tagName.toLowerCase()])\r\n            return;\r\n\r\n        // if(this.incompleteNodes.indexOf(element) < 0)\r\n        this.processElementStart(element);\r\n\r\n        element.childNodes.forEach((node: Node) =>\r\n        {\r\n            this.walkNode(node);\r\n        });\r\n\r\n        this.processElementEnd(element);\r\n    }\r\n\r\n    protected processElementStart(element: Element)\r\n    {\r\n        // console.log(\"processElementStart:\", element);\r\n        this.options.elementStart(element);\r\n    }\r\n    protected processElementEnd(element: Element)\r\n    {\r\n        // console.log(\"processElementEnd:\", element);\r\n        this.options.elementEnd(element);\r\n    }\r\n    protected processComment(node: Comment)\r\n    {\r\n        // console.log(\"processComment:\", node);\r\n        this.options.comment(node);\r\n    }\r\n    protected processText(node: Text)\r\n    {\r\n        // console.log(\"processText:\", node);\r\n        this.options.text(node);\r\n    }\r\n}\r\n","import { createPage, Page, PageOptions } from \"./Page\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport default class LiveDom\r\n{\r\n    public static initPage(options: PageOptions = {}) : Page\r\n    {\r\n        const controller = new PageController(document, options);\r\n        return createPage(controller);\r\n    }\r\n}\r\n\r\n","import { TypeData } from \"./DataManager\";\r\nimport { PageController } from \"./PageController\";\r\n\r\n //TODO singleton for page, and life in doc\r\n\r\nexport interface PageOptions\r\n{\r\n    // container?: Element|string;\r\n    data?: TypeData; //init data\r\n    // directives?: MapObject<DirectiveOptions>;\r\n    loaded?: ()=>void;\r\n    // debug?: boolean;\r\n}\r\n\r\nexport function createPage(controller: PageController) : Page\r\n{\r\n    const page = new Page();\r\n    \r\n    page.updateData = controller.updatePageData.bind(controller);\r\n    // page.onReady = function(cb)\r\n    // {\r\n    //     controller.scanCompletedPromise.then(cb);\r\n    // }\r\n    \r\n    return page;\r\n}\r\n\r\nexport class Page\r\n{\r\n    public updateData: (data: TypeData) => Promise<void>;\r\n    // public onReady: (callback: ()=>void) => void;\r\n}\r\n\r\n","import { DomScanner } from \"./DomScanner\";\r\nimport { DomScannerLoaded } from \"./DomScannerLoaded\";\r\nimport { PageOptions } from \"./Page\";\r\nimport { Directive, DirectiveConfig } from \"./Directive\";\r\nimport { DirectiveElementRender } from \"./DirectiveElementRender\";\r\nimport { DirectiveElementEach } from \"./DirectiveElementEach\";\r\nimport { DataManager, TypeData } from \"./DataManager\";\r\nimport { DirectiveElementIf } from \"./DirectiveElementIf\";\r\nimport { Parser } from \"./Parser\";\r\nimport { AttrInfo, ElementRenderInfo, NodeElementInfo, NodeInfo, NodeTextInfo } from \"./NodeInfo\";\r\nimport { DirectiveElementElse } from \"./DirectiveElementElse\";\r\n\r\n// WeakMap<Document, Map<NodeInfo>>\r\n\r\nconst propLiveInfo = Symbol(\"LiveDomInfoProp\");\r\nconst attrLiveName = \"_ld\";\r\nconst attrLiveEach = \"live:each\";\r\nconst attrLiveIf = \"live:if\";\r\nconst attrLiveElse = \"live:else\";\r\nlet nextId = 1001;\r\n\r\nexport class PageController\r\n{\r\n    public doc: Document;\r\n    public options: PageOptions;\r\n    public dataManager: DataManager;\r\n    public scanCompletedPromise: Promise<void> = null;\r\n    \r\n    private scanner: DomScanner;\r\n    private elementDirectivesConfig: DirectiveConfig<Element>[];\r\n    // private directiveText: DirectiveText;\r\n    // private nodeInfos: MapObject<NodeInfo>;\r\n    private requestRenderPagePromise: Promise<void> = null;\r\n    \r\n    public constructor(doc: Document, options: PageOptions)\r\n    {\r\n        this.doc = doc;\r\n        this.options = options;\r\n        this.dataManager = new DataManager(options.data || {});\r\n        this.elementDirectivesConfig = [\r\n            {attr: attrLiveEach, create: DirectiveElementEach.create, },\r\n            {attr: attrLiveIf, create: DirectiveElementIf.create, },\r\n            {attr: attrLiveElse, create: DirectiveElementElse.create, },\r\n            // {attr: null, create: DirectiveHtmlInputRender.create, },\r\n            {attr: null, create: DirectiveElementRender.create, },\r\n        ];\r\n        // this.directiveText = new DirectiveText();\r\n        // this.nodeInfos = {};\r\n        \r\n        this.scanner = new DomScannerLoaded(document, {\r\n            elementStart: this.scanElementStart.bind(this),\r\n            elementEnd: this.scanElementEnd.bind(this),\r\n            comment: this.scanComment.bind(this),\r\n            text: this.scanText.bind(this),\r\n        });\r\n        \r\n        this.scanCompletedPromise = this.scanner.scan().\r\n        then(() =>\r\n        {\r\n            if(this.options.loaded)\r\n                this.options.loaded();\r\n            \r\n            this.requestRenderPage();\r\n        });\r\n    }\r\n    \r\n    public updatePageData(data: TypeData = {}) : Promise<void>\r\n    {\r\n        // console.log(\"updatePageData:\", data);\r\n        this.dataManager.mergePageData(data);\r\n        return this.requestRenderPage();\r\n    }\r\n    private requestRenderPage() : Promise<void>\r\n    {\r\n        if(this.requestRenderPagePromise)\r\n            return this.requestRenderPagePromise;\r\n        \r\n        return this.requestRenderPagePromise = this.scanCompletedPromise.\r\n        then(() =>\r\n        {\r\n            this.requestRenderPagePromise = null;\r\n            this.renderElement(this.doc.documentElement);\r\n        });\r\n    }\r\n    \r\n    private scanElementStart(element: Element) : void\r\n    {\r\n        // console.log(\"elementStart:\", element);\r\n        this.setupElement(element);\r\n    }\r\n    private scanElementEnd(element: Element) : void\r\n    {\r\n        // this.renderElement(element);\r\n    }\r\n    private scanComment(comment: Comment) : void\r\n    {\r\n        // console.log(\"comment:\", comment);\r\n    }\r\n    private scanText(text: Text) : void\r\n    {\r\n        // console.log(\"text:\", text);\r\n        this.setupText(text);\r\n    }\r\n    \r\n    private setupElement(element: Element)\r\n    {\r\n        const info: NodeElementInfo = {\r\n            id: 'LDE'+(nextId++),\r\n            element,\r\n            placeholderComment: null,\r\n            attrs: {},\r\n            directives: [],\r\n        };\r\n        \r\n        // console.log(\"DirectiveElement build node:\", nodeInfo, node);\r\n        const attrs = element.attributes;\r\n        for(let i=attrs.length-1; i>=0; --i)\r\n        {\r\n            const attr = attrs[i];\r\n            const attrInfo = this.setupAttribute(attr);\r\n            // console.log(\"initElement attribute:\", attr, attrInfo);\r\n            if(attrInfo)\r\n            {\r\n                info.attrs[attr.name] = attrInfo;\r\n                // attr.value = attrInfo.exec(this.data);\r\n            }\r\n        }\r\n        \r\n        this.setupElementDirectives(element, info);\r\n        \r\n        if(Object.keys(info.attrs).length == 0 && Object.keys(info.directives).length == 0)\r\n        {\r\n            this.setNodeInfo(element, null);\r\n            return ;\r\n        }\r\n        \r\n        info.render = this.renderElement.bind(this);\r\n        this.setNodeInfo(element, info);\r\n    }\r\n    private setupElementDirectives(element: Element, info: NodeElementInfo)\r\n    {\r\n        for(const config of this.elementDirectivesConfig)\r\n        {\r\n            const directive = config.create(this, element, info, config);\r\n            if(directive)\r\n                info.directives.push(directive);\r\n        }\r\n    }\r\n    private setupAttribute(attr: Attr) : AttrInfo\r\n    {\r\n        const parseResult = Parser.parseText(attr.value);\r\n        if(!Parser.hasTextExpress(parseResult))\r\n            return null;\r\n        \r\n        return {\r\n            exec: parseResult.exec,\r\n        };\r\n    }\r\n    private renderElement(placeholder: Element)\r\n    {\r\n        const elementInfo = this.getNodeInfo(placeholder) as NodeElementInfo;\r\n        // console.log(\"renderElement:\", placeholder, this.isLiveNode(placeholder), elementInfo);\r\n        if(! elementInfo)\r\n        {\r\n            this.renderChildNodes(placeholder);\r\n            return ;\r\n        }\r\n        \r\n        const exists: Node[] = [placeholder];\r\n        let nextNode = placeholder.nextSibling;\r\n        while(nextNode)\r\n        {\r\n            const nextInfo = this.getNodeInfo(nextNode);\r\n            if(nextInfo != elementInfo)\r\n                break;\r\n            \r\n            exists.push(nextNode);\r\n            nextNode = nextNode.nextSibling;\r\n        }\r\n        \r\n        const renderInfo: ElementRenderInfo = {\r\n            elementInfo,\r\n            exists,\r\n            // attrsVal: {}, //TODO no use\r\n        };\r\n        \r\n        const element = placeholder.nodeType==1 ? placeholder as Element : elementInfo.element;\r\n        const renderElements = this.processElementDirectiveRender(element, renderInfo, 0);\r\n        // console.log(\"renderElement renderElements:\", element, renderElements, renderInfo);\r\n        if(renderElements.length == 0)\r\n        {\r\n            // console.log(\"renderElement renderElements remove:\", exists.length, element.parentNode, element);\r\n            const placeholderComment = this.getPlaceholderComment(elementInfo);\r\n            insertAfter(placeholder, placeholderComment);\r\n            for(const ele of exists)\r\n            {\r\n                // console.log(\">>>>>>>>>>>>>>>>>>>>>>>>\", ele.parentNode, ele);\r\n                if(ele != placeholderComment)\r\n                    removeNode(ele);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            let prev = placeholder;\r\n            for(const ele of renderElements)\r\n            {\r\n                insertAfter(prev, ele);\r\n                prev = ele;\r\n            }\r\n            \r\n            for(const ele of exists)\r\n            {\r\n                if(renderElements.indexOf(ele as Element) < 0)\r\n                    removeNode(ele);\r\n            }\r\n        }\r\n    }\r\n    private processElementDirectiveRender(element: Element, renderInfo: ElementRenderInfo, directiveIndex: number) : Element[]\r\n    {\r\n        const directives = renderInfo.elementInfo.directives;\r\n        \r\n        if(directiveIndex < directives.length)\r\n        {\r\n            return directives[directiveIndex].render(\r\n                element,\r\n                renderInfo, \r\n                (ele: Element, info: ElementRenderInfo) => this.processElementDirectiveRender(ele, info, directiveIndex+1)\r\n            );\r\n        }\r\n        \r\n        return [element];\r\n    }\r\n    public isPlaceholder(node: Node) : boolean\r\n    {\r\n        if(node.nodeType != 8) //8: Node.COMMENT_NODE\r\n            return false;\r\n        \r\n        const info = this.getNodeInfo(node) as NodeElementInfo;\r\n        return info.placeholderComment == node;\r\n    }\r\n    private getPlaceholderComment(info: NodeElementInfo) : Comment\r\n    {\r\n        if(info.placeholderComment)\r\n            return info.placeholderComment;\r\n        \r\n        info.placeholderComment = this.doc.createComment(\"_LiveDomId=\"+info.id);\r\n        this.setNodeInfo(info.placeholderComment, info);\r\n        return info.placeholderComment;\r\n    }\r\n    public renderChildNodes(parentNode: Node)\r\n    {\r\n        const t = nextId ++;\r\n        const nodes = [];\r\n        const l = parentNode.childNodes.length;\r\n        for(let i=0; i<l; ++i)\r\n            nodes.push(parentNode.childNodes[i]);\r\n        \r\n        for(let i=0; i<l; ++i)\r\n        {\r\n            const node = nodes[i];\r\n            const info = this.getNodeInfo(node);\r\n            if(!info)\r\n            {\r\n                if(node.nodeType == 1) // 1: Node.ELEMENT_NODE\r\n                    this.renderChildNodes(node);\r\n                continue;\r\n            }\r\n            \r\n            if(info._t == t)\r\n                continue;\r\n            \r\n            info.render(node);\r\n            info._t = t;\r\n        }\r\n    }\r\n    \r\n    private setupText(text: Text)\r\n    {\r\n        const parseResult = Parser.parseText(text.data);\r\n        // console.log(\"buildNode parseText:\", parseResult, parseResult.exec({}));\r\n        if(!Parser.hasTextExpress(parseResult))\r\n            return ;\r\n        \r\n        const info: NodeTextInfo = {\r\n            id: 'LDT'+(nextId++),\r\n        };\r\n        \r\n        // console.log(\"buildNode:\", info, text);\r\n        info.render = (node: Text) =>\r\n        {\r\n            node.data = parseResult.exec(this.dataManager.data);\r\n        }\r\n        this.setNodeInfo(text, info);\r\n        // info.render(text);\r\n    }\r\n    \r\n    public cloneNode<N extends Node>(src: N): N\r\n    {\r\n        const des = src.cloneNode(true);\r\n        this.cloneNodesInfo([src], [des]);\r\n        return des as N;\r\n    }\r\n    private cloneNodesInfo(srcNodes: Node[]|NodeListOf<ChildNode>, desNodes: Node[]|NodeListOf<ChildNode>)\r\n    {\r\n        for(let i=0, l=srcNodes.length; i < l; ++i)\r\n        {\r\n            desNodes[i][propLiveInfo] = srcNodes[i][propLiveInfo];\r\n            \r\n            if(srcNodes[i].nodeType == 1) // 1: Node.ELEMENT_NODE\r\n                this.cloneNodesInfo(srcNodes[i].childNodes, desNodes[i].childNodes);\r\n        }\r\n    }\r\n    \r\n    private setNodeInfo(node: Node, info: NodeInfo)\r\n    {\r\n        //weak map ?\r\n        //prop map ?\r\n        node[propLiveInfo] = info;\r\n    }\r\n    public getNodeInfo(node: Node) : NodeInfo\r\n    {\r\n        return node[propLiveInfo] || null;\r\n    }\r\n    private hasNodeInfo(node: Node) : boolean\r\n    {\r\n        return !!node[propLiveInfo];\r\n    }\r\n    private isLiveNode(node: Node) : boolean\r\n    {\r\n        return propLiveInfo in node;\r\n    }\r\n}\r\n\r\n\r\nfunction removeNode(node: Node)\r\n{\r\n    if(node.parentNode)\r\n        node.parentNode.removeChild(node);\r\n}\r\n\r\nfunction insertAfter(before: Node, node: Node)\r\n{\r\n    // console.log(\"insertAfter:\", before, node, before==node, !!before.nextSibling, !!node.parentNode);\r\n    if(before == node)\r\n        return ;\r\n    else if(before.nextSibling)\r\n        before.parentNode.insertBefore(node, before.nextSibling);\r\n    else\r\n        before.parentNode.appendChild(node);\r\n}\r\n\r\n","import { TypeData } from \"./DataManager\";\r\n\r\n//TODO isUseMergeData() field1!==undefined || field1.field2!==undefined || ...\r\n\r\nexport type TextFunction<R=any> = (data: TypeData) => R;\r\n\r\ninterface ParseTextResult\r\n{\r\n    // vars: string[];\r\n    parts: (string|TextFunction)[];\r\n    // keyPaths: {[k: string]: string[]};\r\n    exec(data: TypeData);\r\n}\r\n\r\nexport class Parser\r\n{\r\n    public static parseText(text: string) : ParseTextResult\r\n    {\r\n        const expressionRegex = /\\$\\{\\s*([a-zA-z_]\\w*(\\.\\w+)*)\\s*\\}/g;\r\n        // console.log(\"parseText:\", text.length, text.match(expressionRegex));\r\n        const parts: (string|TextFunction)[] = [];\r\n        let match: RegExpExecArray = null;\r\n        let lastIndex = 0;\r\n        \r\n        while(match = expressionRegex.exec(text))\r\n        {\r\n            if(lastIndex < match.index)\r\n                parts.push(text.substring(lastIndex, match.index));\r\n            \r\n            // console.log(\"parseText result:\", result, expressionRegex.lastIndex);\r\n            const names = match[1].split(/\\./g);\r\n            parts.push(buildTextFunction(names));\r\n            \r\n            lastIndex = expressionRegex.lastIndex;\r\n        }\r\n        \r\n        if(lastIndex < text.length)\r\n            parts.push(text.substring(lastIndex, text.length));\r\n        // console.log(\"parseText lastIndex:\", expressionRegex.lastIndex, parts);\r\n        \r\n        return {parts, exec: buildParseResultRenderer(parts)}; //TODO isUseMergeData()\r\n    }\r\n\r\n    public static hasTextExpress(result: ParseTextResult)\r\n    {\r\n        if(result.parts.length > 1)\r\n            return true;\r\n        \r\n        return result.parts.length == 1 && typeof(result.parts[0]) != \"string\";\r\n    }\r\n}\r\n\r\n\r\n// function getWatchVars(info: ParseTextExpressionInfo): string[]\r\n// {\r\n//     // return [info.var.replace(/\\s*\\.\\s*/g, \".\")];\r\n//     return info.var.split(/\\s*\\.\\s*/, 1).slice(0, 1);\r\n// }\r\n\r\nfunction buildTextFunction(names: string[]) : TextFunction\r\n{\r\n    let lastNamePath = \"\";\r\n    let namesPath = names.map((name) =>\r\n    {\r\n        lastNamePath = lastNamePath + \".\" + name;\r\n        return lastNamePath.substring(1);\r\n    });\r\n    \r\n    // let body = \"return data\" + names.map(name => '[\"'+name+'\"]').join(\"\") + \";\";\r\n    let body = `var ${names[0]}=data.${names[0]}; `\r\n            + `return (${namesPath.map(p => `${p}!==null&&${p}!==void 0`).join(\" && \")}) ? ${names.join(\".\")} : null;`;\r\n    \r\n    // console.log(\"buildTextRenderer:\", names, namesPath, body);\r\n    return new Function(\"data\", body) as TextFunction;\r\n}\r\n\r\nfunction buildParseResultRenderer(parts: (string|TextFunction)[])\r\n{\r\n    if(parts.length == 1 && typeof(parts[0]) == \"function\")\r\n    {\r\n        return parts[0];\r\n    }\r\n    \r\n    if(parts.length == 1 && typeof(parts[0]) == \"string\")\r\n    {\r\n        const text = parts[0];\r\n        return function() { return text; };\r\n    }\r\n    \r\n    return function(data: TypeData)\r\n    {\r\n        const results: string[] = [];\r\n        for(const p of parts)\r\n        {\r\n            if(typeof(p) == \"string\")\r\n                results.push(p);\r\n            else\r\n                results.push(p(data));\r\n        }\r\n        \r\n        // console.log(\"textNodeRenderer results:\", results, data);\r\n        return results.join(\"\");\r\n    };\r\n}\r\n\r\n\r\n\r\n","import LiveDom from \"./LiveDom\";\r\n\r\n// console.log(\">>>>>>>>>>>>> LiveDom:\", LiveDom);\r\n\r\n// export function testLiveDom()\r\n// {\r\n//     console.log(\">>>>>>>>>>>>> testLiveDom:\", LiveDom);\r\n    \r\n// }\r\n\r\n// window[\"LiveDom\"] = LiveDom;\r\n\r\nexport = LiveDom;\r\n"]}