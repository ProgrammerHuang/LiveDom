{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/DataManager.ts","src/Directive.ts","src/DirectiveElementEach.ts","src/DirectiveElementIf.ts","src/DirectiveElementRender.ts","src/DomScanner.ts","src/DomScannerLoaded.ts","src/LiveDom.ts","src/Page.ts","src/PageController.ts","src/Parser.ts","src/main.ts"],"names":["f","exports","module","define","amd","window","global","self","this","LiveDom","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","DataManager","constructor","initData","pageData","Object","create","scopeDataStack","data","mergePageData","assign","pushScopeData","scopeData","push","popScopeData","pop","getPrototypeOf","Directive","controller","Directive_1","propLiveKeyData","Symbol","DirectiveElementEach","element","attrInfo","super","info","config","attrs","attr","removeAttribute","render","continueRender","elementInfo","items","exec","dataManager","let","renderElements","item","keyVal","itemElement","exists","find","ele","indexOf","cloneNode","itemRenderElements","DirectiveElementIf","DirectiveElementRender","attrName","attrVal","setAttribute","renderChildNodes","DomScanner","doc","options","ignoreElementTags","script","style","observer","MutationObserver","mutationObserverCallback","bind","mutationList","DomScannerLoaded","scanPromise","scan","Promise","resolve","reject","readyState","walkNode","documentElement","completed","observe","subtree","childList","attributes","characterData","addEventListener","node","nodeType","processElement","processText","processComment","tagName","toLowerCase","processElementStart","childNodes","forEach","processElementEnd","elementStart","elementEnd","comment","text","PageController_1","default","init","PageController","document","parse","then","page","Page","DomScannerLoaded_1","Page_1","DirectiveElementRender_1","DirectiveElementEach_1","DataManager_1","DirectiveElementIf_1","Parser_1","propLiveInfo","nextId","removeNode","parentNode","removeChild","insertAfter","before","nextSibling","insertBefore","appendChild","elementDirectivesConfig","nodeInfos","scanner","scanElementStart","scanElementEnd","scanComment","scanText","scanCompleted","initPage","updateData","updatePageData","renderElement","setupElement","setupText","id","placeholderComment","directives","directiveAttrs","setupAttribute","name","setupElementDirectives","keys","setNodeInfo","directive","parseResult","Parser","parseText","value","hasTextExpress","placeholder","getNodeInfo","nextNode","renderInfo","renders","attrsVal","directivesVal","processElementDirectiveRender","getPlaceholderComment","prev","directiveIndex","createComment","nodes","l","_t","src","des","cloneNodesInfo","srcNodes","desNodes","hasNodeInfo","isLiveNode","expressionRegex","parts","match","lastIndex","index","substring","names","split","lastNamePath","namesPath","map","body","join","Function","buildTextFunction","results","buildParseResultRenderer","result","LiveDom_1"],"mappings":"CAAA,SAAAA,GAAA,iBAAAC,SAAA,oBAAAC,OAAAA,OAAAD,QAAAD,IAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,IAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAAC,KAAAA,KAAAC,MAAAC,QAAAT,IAAA,CAAA,WAAA,OAAA,SAAAU,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAf,GAAA,IAAAY,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAC,EAAA,mBAAAC,SAAAA,QAAA,IAAAjB,GAAAgB,EAAA,OAAAA,EAAAD,GAAA,GAAA,GAAAG,EAAA,OAAAA,EAAAH,GAAA,GAAA,MAAAI,EAAA,IAAAC,MAAA,uBAAAL,EAAA,MAAAM,KAAA,mBAAAF,EAAAG,EAAAV,EAAAG,GAAA,CAAAd,QAAA,IAAAU,EAAAI,GAAA,GAAAQ,KAAAD,EAAArB,QAAA,SAAAS,GAAA,OAAAI,EAAAH,EAAAI,GAAA,GAAAL,IAAAA,IAAAY,EAAAA,EAAArB,QAAAS,EAAAC,EAAAC,EAAAC,GAAA,OAAAD,EAAAG,GAAAd,QAAA,IAAA,IAAAiB,EAAA,mBAAAD,SAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,EAAA,CAAA,CAAAW,EAAA,CAAA,SAAAR,EAAAf,EAAAD,gB,sECEAA,EAAAyB,kBAOIC,YAAmBC,GAEfpB,KAAKoB,SAAWA,EAChBpB,KAAKqB,SAAWC,OAAOC,OAAOvB,KAAKoB,UAEnCpB,KAAKwB,eAAiB,GAEtBxB,KAAKyB,KAAOH,OAAOC,OAAOvB,KAAKqB,UAG5BK,cAAcL,GAEjBC,OAAOK,OAAO3B,KAAKqB,SAAUA,GAG1BO,cAAcC,GAEjB7B,KAAKwB,eAAeM,KAAKD,GACzB7B,KAAKyB,KAAOH,OAAOC,OAAOvB,KAAKyB,MAC/BH,OAAOK,OAAO3B,KAAKyB,KAAMI,GAEtBE,aAAaF,GAEhB,GAAI7B,KAAKwB,eAAexB,KAAKwB,eAAeR,OAAS,IAAMa,EACvD,MAAM,IAAIjB,MAAM,+CAEpBZ,KAAKwB,eAAeQ,MACpBhC,KAAKyB,KAAOH,OAAOW,eAAejC,KAAKyB,S,wGClB/ChC,EAAAyC,gBAOIf,YAAsBgB,GAElBnC,KAAKmC,WAAaA,K,mHC3B1BC,EAAA3B,EAAA,eAIA,MAAM4B,EAAkBC,OAAO,4BAElBC,UAA6BH,EAAAF,UAkBtCf,YAAsBgB,EAA4BK,EAAkBC,GAEhEC,MAAMP,GAENnC,KAAKyC,SAAWA,EApBblB,cAAcY,EAA4BK,EAAkBG,EAAuBC,GAEtF,IAAKD,EAAKE,MAAMD,EAAOE,MACnB,OAAO,KAEX,IAAML,EAAWE,EAAKE,MAAMD,EAAOE,MAKnC,OAHAN,EAAQO,gBAAgBH,EAAOE,aACxBH,EAAKE,MAAMD,EAAOE,MAElB,IAAIP,EAAqBJ,EAAYK,EAASC,GAalDO,OAAOR,EAAkBG,EAAyBM,GAGrD,IAAMC,EAAcP,EAAKO,YAEnBC,EAAQnD,KAAKyC,SAASW,KAAKpD,KAAKmC,WAAWkB,YAAY5B,MAG7D6B,IAAIC,EAA4B,GAChC,IAAK,MAAMC,KAAQL,GAAS,GAC5B,CAEI,MAAMM,EAASD,EAMTE,EAAcf,EAAKgB,OAAOC,KAAK,GAAkBvB,KAAmBwB,GAAOA,EAAIxB,IAAoBoB,GAAUF,EAAeO,QAAQD,GAAO,IAC7I7D,KAAKmC,WAAW4B,UAAUb,EAAYV,SAC1CkB,EAAYrB,GAAmBoB,EAE/B,IAAM5B,EAAY,CAAE2B,KAAAA,GAEdQ,GADNhE,KAAKmC,WAAWkB,YAAYzB,cAAcC,GACfoB,EAAeS,EAAaf,IACvD3C,KAAKmC,WAAWkB,YAAYtB,aAAaF,GAET,EAA5BmC,EAAmBhD,QACnBuC,EAAezB,KAAKkC,EAAmB,IAG/C,OAAOT,GAxDf9D,EAAA8C,qBAAAA,G,sICFa0B,UAJbxD,EAAA,eAIwCyB,UAkBpCf,YAAsBgB,EAA4BK,EAAkBC,GAEhEC,MAAMP,GAENnC,KAAKyC,SAAWA,EApBblB,cAAcY,EAA4BK,EAAkBG,EAAuBC,GAEtF,IAAKD,EAAKE,MAAMD,EAAOE,MACnB,OAAO,KAEX,IAAML,EAAWE,EAAKE,MAAMD,EAAOE,MAKnC,OAHAN,EAAQO,gBAAgBH,EAAOE,aACxBH,EAAKE,MAAMD,EAAOE,MAElB,IAAImB,EAAmB9B,EAAYK,EAASC,GAahDO,OAAOR,EAAkBG,EAAyBM,GAGjCN,EAAKO,YAIzB,OAFYlD,KAAKyC,SAASW,KAAKpD,KAAKmC,WAAWkB,YAAY5B,MAGhDwB,EAAeT,EAASG,GAE5B,IAnCflD,EAAAwE,mBAAAA,G,0ICAaC,UAJbzD,EAAA,eAI4CyB,UAEjCX,cAAcY,EAA4BK,EAAkBG,EAAuBC,GAEtF,OAAO,IAAIsB,EAAuB/B,GAG/Ba,OAAOR,EAAkBG,EAAyBM,GAGrD,IAAMC,EAAcP,EAAKO,YAEzB,IAAK,MAAMiB,KAAYjB,EAAYL,MACnC,CAGI,MAAMJ,EAAWS,EAAYL,MAAMsB,GACnC,IAAMC,EAAU3B,EAASW,KAAKpD,KAAKmC,WAAWkB,YAAY5B,MAE1De,EAAQ6B,aAAaF,EAAUC,GAKnC,OAFApE,KAAKmC,WAAWmC,iBAAiB9B,GAE1BS,EAAeT,EAASG,IAxBvClD,EAAAyE,uBAAAA,G,wHCOAzE,EAAA8E,iBAOIpD,YAAmBqD,EAAeC,GAFxBzE,KAAA0E,kBAAoB,CAACC,QAAQ,EAAMC,OAAO,GAIhD5E,KAAKyE,QAAUA,EACfzE,KAAKwE,IAAMA,EACXxE,KAAK6E,SAAW,IAAIC,iBAAiB9E,KAAK+E,yBAAyBC,KAAKhF,OAKpE+E,yBAAyBE,O,qHCzBxBC,UAFbzE,EAAA,gBAEsC8D,WAAtCpD,c,oBAEcnB,KAAAmF,YAA6B,KAEhCC,OAEH,OAAIpF,KAAKmF,cAGFnF,KAAKmF,YAAc,IAAIE,QAAc,CAACC,EAASC,KAEvB,YAAvBvF,KAAKwE,IAAIgB,YAETxF,KAAKyF,SAASzF,KAAKwE,IAAIkB,iBACvB1F,KAAKyE,QAAQkB,YACb3F,KAAK6E,SAASe,QAAQ5F,KAAKwE,IAAIkB,gBAAiB,CAAEG,SAAS,EAAMC,WAAW,EAAMC,YAAY,EAAMC,eAAe,IACnHV,KAKAtF,KAAKwE,IAAIyB,iBAAiB,mBAAoB,KAE1CjG,KAAKyF,SAASzF,KAAKwE,IAAIkB,iBACvB1F,KAAKyE,QAAQkB,YACb3F,KAAK6E,SAASe,QAAQ5F,KAAKwE,IAAIkB,gBAAiB,CAAEG,SAAS,EAAMC,WAAW,EAAMC,YAAY,EAAMC,eAAe,IACnHV,SAMNG,SAASS,GAGf,OAAQA,EAAKC,UAET,KAAK,EACDnG,KAAKoG,eAAeF,GACpB,MACJ,KAAK,EACDlG,KAAKqG,YAAYH,GACjB,MAOJ,KAAK,EACDlG,KAAKsG,eAAeJ,IAQtBE,eAAe5D,GAGjBxC,KAAK0E,kBAAkBlC,EAAQ+D,QAAQC,iBAI3CxG,KAAKyG,oBAAoBjE,GAEzBA,EAAQkE,WAAWC,QAAQ,IAEvB3G,KAAKyF,SAASS,KAGlBlG,KAAK4G,kBAAkBpE,IAGjBiE,oBAAoBjE,GAG1BxC,KAAKyE,QAAQoC,aAAarE,GAEpBoE,kBAAkBpE,GAGxBxC,KAAKyE,QAAQqC,WAAWtE,GAElB8D,eAAeJ,GAGrBlG,KAAKyE,QAAQsC,QAAQb,GAEfG,YAAYH,GAGlBlG,KAAKyE,QAAQuC,KAAKd,IA7F1BzG,EAAAyF,iBAAAA,G,qGCDA,MAAA+B,EAAAxG,EAAA,oBAQAhB,EAAAyH,cAEWC,YAAY1C,EAAuB,IAEtC,MAAMtC,EAAa,IAAI8E,EAAAG,eAAeC,SAAU5C,GAEhD,OAAOtC,EAAWmF,QAAQC,KAAK,IAAMpF,EAAWqF,S,wHCJxD/H,EAAAgI,c,8GCTA,MAAAC,EAAAjH,EAAA,sBACAkH,EAAAlH,EAAA,UAEAmH,EAAAnH,EAAA,4BACAoH,EAAApH,EAAA,0BACAqH,EAAArH,EAAA,iBACAsH,EAAAtH,EAAA,wBACAuH,EAAAvH,EAAA,YAiBMwH,EAAe3F,OAAO,mBAK5BgB,IAAI4E,EAAS,KA2Tb,SAASC,EAAWjC,GAEbA,EAAKkC,YACJlC,EAAKkC,WAAWC,YAAYnC,GAGpC,SAASoC,EAAYC,EAAcrC,GAG5BqC,GAAUrC,IAELqC,EAAOC,YACXD,EAAOH,WAAWK,aAAavC,EAAMqC,EAAOC,aAE5CD,EAAOH,WAAWM,YAAYxC,IAvUtCzG,EAAA2H,qBAaIjG,YAAmBqD,EAAeC,GAE9BzE,KAAKwE,IAAMA,EACXxE,KAAKyE,QAAUA,EACfzE,KAAKqD,YAAc,IAAIyE,EAAA5G,YAAYuD,EAAQhD,MAAQ,IACnDzB,KAAK2I,wBAA0B,CAC3B,CAAC7F,KAxBQ,YAwBYvB,OAAQsG,EAAAtF,qBAAqBhB,QAClD,CAACuB,KAxBM,UAwBYvB,OAAQwG,EAAA9D,mBAAmB1C,QAC9C,CAACuB,KAAM,KAAMvB,OAAQqG,EAAA1D,uBAAuB3C,SAGhDvB,KAAK4I,UAAY,GAEjB5I,KAAK6I,QAAU,IAAInB,EAAAxC,iBAAiBmC,SAAU,CAC1CR,aAAc7G,KAAK8I,iBAAiB9D,KAAKhF,MACzC8G,WAAY9G,KAAK+I,eAAe/D,KAAKhF,MACrC+G,QAAS/G,KAAKgJ,YAAYhE,KAAKhF,MAC/BgH,KAAMhH,KAAKiJ,SAASjE,KAAKhF,MACzB2F,UAAW3F,KAAKkJ,cAAclE,KAAKhF,QAEvCA,KAAK6I,QAAQzD,OAIbpF,KAAKmJ,WAKDA,WAEJnJ,KAAKwH,KAAO,IAAIG,EAAAF,KAChBzH,KAAKwH,KAAK4B,WAAapJ,KAAKqJ,eAAerE,KAAKhF,MAE5CqJ,eAAe5H,EAAiB,IAKpC,OAFAzB,KAAKqD,YAAY3B,cAAcD,GAC/BzB,KAAKsJ,cAActJ,KAAKwE,IAAIkB,iBACrBL,QAAQC,UAGZgC,QAEH,OAAOtH,KAAK6I,QAAQzD,OAGhB0D,iBAAiBtG,GAIrBxC,KAAKuJ,aAAa/G,GAEduG,eAAevG,IAIfwG,YAAYjC,IAIZkC,SAASjC,GAIbhH,KAAKwJ,UAAUxC,GAEXkC,gBAEJlJ,KAAKsJ,cAActJ,KAAKwE,IAAIkB,iBAGxB6D,aAAa/G,GAEjB,MAAMG,EAAwB,CAC1B8G,GAAI,MAAOvB,IACX1F,QAAAA,EACAkH,mBAAoB,KACpB7G,MAAO,GACP8G,WAAY,GACZC,eAAgB,IAKpB,IAAM/G,EAAQL,EAAQuD,WACtB,IAAIzC,IAAI/C,EAAEsC,EAAM7B,OAAO,EAAM,GAAHT,IAAQA,EAClC,CACI,IAAMuC,EAAOD,EAAMtC,GACbkC,EAAWzC,KAAK6J,eAAe/G,GAElCL,IAECE,EAAKE,MAAMC,EAAKgH,MAAQrH,GAKhCzC,KAAK+J,uBAAuBvH,EAASG,GAEA,GAAlCrB,OAAO0I,KAAKrH,EAAKE,OAAO7B,QAAsD,GAAvCM,OAAO0I,KAAKrH,EAAKgH,YAAY3I,QAA0D,GAA3CM,OAAO0I,KAAKrH,EAAKiH,gBAAgB5I,OAEnHhB,KAAKiK,YAAYzH,EAAS,OAI9BG,EAAKK,OAAShD,KAAKsJ,cAActE,KAAKhF,MACtCA,KAAKiK,YAAYzH,EAASG,IAEtBoH,uBAAuBvH,EAAkBG,GAE7C,IAAI,MAAMC,KAAU5C,KAAK2I,wBACzB,CACI,IAAMuB,EAAYtH,EAAOrB,OAAOvB,KAAMwC,EAASG,EAAMC,GAClDsH,GACCvH,EAAKgH,WAAW7H,KAAKoI,IAGzBL,eAAe/G,GAEbqH,EAAcnC,EAAAoC,OAAOC,UAAUvH,EAAKwH,OAC1C,OAAItC,EAAAoC,OAAOG,eAAeJ,GAGnB,CACH/G,KAAM+G,EAAY/G,MAHX,KAMPkG,cAAckB,GAElB,IAAMtH,EAAclD,KAAKyK,YAAYD,GAGrC,GAAKtH,EAAL,CAMA,MAAMS,EAAiB,CAAC6G,GACxBlH,IAAIoH,EAAWF,EAAYhC,YAC3B,KAAMkC,GACN,CAEI,GADiB1K,KAAKyK,YAAYC,IACnBxH,EACX,MAEJS,EAAO7B,KAAK4I,GACZA,EAAWA,EAASlC,YAGxB,IAAMmC,EAAgC,CAClCzH,YAAAA,EACAS,OAAAA,EACAiH,QAAS,GACTC,SAAU,GACVC,cAAe,IAGbtI,EAAgC,GAAtBgI,EAAYrE,SAAcqE,EAAyBtH,EAAYV,QAE/E,MAAMe,EAAiBvD,KAAK+K,8BAA8BvI,EAASmI,EAAY,GAE/E,GAA4B,GAAzBpH,EAAevC,OAClB,CAEI,IAAM0I,EAAqB1J,KAAKgL,sBAAsB9H,GACtDoF,EAAYkC,EAAad,GACzB,IAAI,MAAM7F,KAAOF,EAGVE,GAAO6F,GACNvB,EAAWtE,OAIvB,CACIP,IAAI2H,EAAOT,EACX,IAAI,MAAM3G,KAAON,EAEb+E,EAAY2C,EAAMpH,GAClBoH,EAAOpH,EAGX,IAAI,MAAMA,KAAOF,EAEVJ,EAAeO,QAAQD,GAAkB,GACxCsE,EAAWtE,SApDnB7D,KAAKsE,iBAAiBkG,GAwDtBO,8BAA8BvI,EAAkBmI,EAA+BO,GAEnF,MAAMvB,EAAagB,EAAWzH,YAAYyG,WAE1C,OAAGuB,EAAiBvB,EAAW3I,OAEpB2I,EAAWuB,GAAgBlI,OAC9BR,EACAmI,EACA,CAAC9G,EAAclB,IAA4B3C,KAAK+K,8BAA8BlH,EAAKlB,EAAMuI,EAAe,IAIzG,CAAC1I,GAEJwI,sBAAsBrI,GAE1B,OAAGA,EAAK+G,qBAGR/G,EAAK+G,mBAAqB1J,KAAKwE,IAAI2G,cAAc,cAAcxI,EAAK8G,IACpEzJ,KAAKiK,YAAYtH,EAAK+G,mBAAoB/G,GACnCA,EAAK+G,oBAETpF,iBAAiB8D,GAEpB,IAAM/H,EAAI6H,IACV,MAAMkD,EAAQ,GACd,IAAMC,EAAIjD,EAAW1B,WAAW1F,OAChC,IAAIsC,IAAI/C,EAAE,EAAGA,EAAE8K,IAAK9K,EAChB6K,EAAMtJ,KAAKsG,EAAW1B,WAAWnG,IAErC,IAAI+C,IAAI/C,EAAE,EAAGA,EAAE8K,IAAK9K,EACpB,CACI,IAAM2F,EAAOkF,EAAM7K,GACnB,MAAMoC,EAAO3C,KAAKyK,YAAYvE,GAC1BvD,EAODA,EAAK2I,IAAMjL,IAGdsC,EAAKK,OAAOkD,GACZvD,EAAK2I,GAAKjL,GATc,GAAjB6F,EAAKC,UACJnG,KAAKsE,iBAAiB4B,IAY9BsD,UAAUxC,GAEd,MAAMmD,EAAcnC,EAAAoC,OAAOC,UAAUrD,EAAKvF,MAE1C,GAAIuG,EAAAoC,OAAOG,eAAeJ,GAA1B,CAGA,MAAMxH,EAAqB,CACvB8G,GAAI,MAAOvB,KAIfvF,EAAKK,OAAS,IAEVkD,EAAKzE,KAAO0I,EAAY/G,KAAKpD,KAAKqD,YAAY5B,OAElDzB,KAAKiK,YAAYjD,EAAMrE,IAIpBoB,UAA0BwH,GAE7B,IAAMC,EAAMD,EAAIxH,WAAU,GAE1B,OADA/D,KAAKyL,eAAe,CAACF,GAAM,CAACC,IACrBA,EAEHC,eAAeC,EAAwCC,GAE3D,IAAIrI,IAAI/C,EAAE,EAAG8K,EAAEK,EAAS1K,OAAQT,EAAI8K,IAAK9K,EAErCoL,EAASpL,GAAG0H,GAAgByD,EAASnL,GAAG0H,GAEb,GAAxByD,EAASnL,GAAG4F,UACXnG,KAAKyL,eAAeC,EAASnL,GAAGmG,WAAYiF,EAASpL,GAAGmG,YAI5DuD,YAAY/D,EAAYvD,GAI5BuD,EAAK+B,GAAgBtF,EAEjB8H,YAAYvE,GAEhB,OAAOA,EAAK+B,IAAiB,KAEzB2D,YAAY1F,GAEhB,QAASA,EAAK+B,GAEV4D,WAAW3F,GAEf,OAAO+B,KAAgB/B,K,wPC3U/BzG,EAAA2K,aAGWC,iBAAiBrD,GAEpB,MAAM8E,EAAkB,sCAElBC,EAAiC,GACvCzI,IAAI0I,EAAyB,KACzBC,EAAY,EAEhB,KAAMD,EAAQF,EAAgB1I,KAAK4D,IACnC,CACOiF,EAAYD,EAAME,OACjBH,EAAMjK,KAAKkF,EAAKmF,UAAUF,EAAWD,EAAME,QAG/C,IAAME,EAAQJ,EAAM,GAAGK,MAAM,OAC7BN,EAAMjK,KA4BlB,SAA2BsK,GAEvB9I,IAAIgJ,EAAe,GACfC,EAAYH,EAAMI,IAAI,IAEtBF,EAAeA,EAAe,IAAMxC,GAChBqC,UAAU,IAI9BM,SAAcL,EAAM,WAAWA,EAAM,kBACpBG,EAAUC,IAAI1L,GAAQA,cAAaA,cAAc4L,KAAK,cAAcN,EAAMM,KAAK,eAGpG,OAAO,IAAIC,SAAS,OAAQF,GA1CTG,CAAkBR,IAE7BH,EAAYH,EAAgBG,UAOhC,OAJGA,EAAYjF,EAAKhG,QAChB+K,EAAMjK,KAAKkF,EAAKmF,UAAUF,EAAWjF,EAAKhG,SAGvC,CAAC+K,MAAAA,EAAO3I,KAoCvB,SAAkC2I,GAE9B,GAAmB,GAAhBA,EAAM/K,QAAmC,mBAAb+K,EAAM,GAEjC,OAAOA,EAAM,GAGjB,GAAmB,GAAhBA,EAAM/K,QAAmC,iBAAb+K,EAAM,GAMrC,OAAO,SAAStK,GAEZ,MAAMoL,EAAoB,GAC1B,IAAI,MAAM/L,KAAKiL,EAEK,iBAAP,EACLc,EAAQ/K,KAAKhB,GAEb+L,EAAQ/K,KAAKhB,EAAEW,IAIvB,OAAOoL,EAAQH,KAAK,KAjBxB,CACI,MAAM1F,EAAO+E,EAAM,GACnB,OAAO,WAAa,OAAO/E,IA9CN8F,CAAyBf,IAG3CxB,sBAAsBwC,GAEzB,OAAyB,EAAtBA,EAAOhB,MAAM/K,QAGc,GAAvB+L,EAAOhB,MAAM/K,QAA0C,iBAApB+L,EAAOhB,MAAM,M,qCC7C/DiB,EAAAvM,EAAA,aAYAf,EAAAD,QAASuN,EAAA9F,mCZZT","file":"livedom.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import { TypeData } from \"./LiveDom\";\r\n\r\nexport class DataManager\r\n{\r\n    public data: TypeData;\r\n    public initData: TypeData;\r\n    public pageData: TypeData;\r\n    private scopeDataStack: TypeData[];\r\n\r\n    public constructor(initData: TypeData)\r\n    {\r\n        this.initData = initData;\r\n        this.pageData = Object.create(this.initData);\r\n\r\n        this.scopeDataStack = [];\r\n\r\n        this.data = Object.create(this.pageData);\r\n    }\r\n\r\n    public mergePageData(pageData: TypeData)\r\n    {\r\n        Object.assign(this.pageData, pageData);\r\n    }\r\n\r\n    public pushScopeData(scopeData: TypeData)\r\n    {\r\n        this.scopeDataStack.push(scopeData);\r\n        this.data = Object.create(this.data);\r\n        Object.assign(this.data, scopeData);\r\n    }\r\n    public popScopeData(scopeData: TypeData)\r\n    {\r\n        if (this.scopeDataStack[this.scopeDataStack.length - 1] != scopeData)\r\n            throw new Error(\"popScopeData fail! scopeData not last data.\");\r\n\r\n        this.scopeDataStack.pop();\r\n        this.data = Object.getPrototypeOf(this.data);\r\n    }\r\n}\r\n","import { PageController } from \"./PageController\";\r\nimport { ElementRenderInfo, NodeInfo } from \"./NodeInfo\";\r\n\r\nexport interface DirectiveConfig\r\n{\r\n    attr?: string;\r\n    create: (controller: PageController, ele: Element, info: NodeInfo, config: DirectiveConfig)=>Directive|null;\r\n}\r\n\r\nexport interface DirectiveRender<N extends Node = Node>\r\n{\r\n    (element: N, renderInfo: ElementRenderInfo): N[];\r\n}\r\n// class DirectiveText extends Directive\r\n// {\r\n// }\r\n\r\n\r\nexport abstract class Directive\r\n{\r\n    // public name: string = null;\r\n    // public abstract buildNode(nodeInfo: NodeInfo, node: Node);\r\n    public abstract render(element: Element, renderInfo: ElementRenderInfo, continueRender: DirectiveRender): Element[];\r\n    // public abstract unsetNode(nodeInfo: NodeInfo);\r\n    protected controller: PageController;\r\n    protected constructor(controller: PageController)\r\n    {\r\n        this.controller = controller;\r\n    }\r\n}\r\n\r\n// class DirectiveElementStateClass extends Directive //live-state=\"rendering|complete\"\r\n// {\r\n// }\r\n// class DirectiveElementContent extends Directive //live:cont\r\n// {\r\n// }\r\n\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nconst propLiveKeyData = Symbol(\"LiveDomKeyDataProp\");\r\n\r\nexport class DirectiveElementEach extends Directive\r\n{\r\n    public static create(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig): DirectiveElementEach\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return null;\r\n\r\n        const attrInfo = info.attrs[config.attr];\r\n\r\n        element.removeAttribute(config.attr);\r\n        delete info.attrs[config.attr];\r\n\r\n        return new DirectiveElementEach(controller, element, attrInfo);\r\n    }\r\n\r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n\r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n\r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        const elementInfo = info.elementInfo;\r\n        // const directiveAttrInfo = elementInfo.directiveAttrs[attrLiveEach];\r\n        const items = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        // info.directivesVal[attrLiveEach] = items;\r\n        let renderElements: Element[] = [];\r\n        for (const item of items || [])\r\n        {\r\n            // console.log(\"DirectiveElementEach item:\", item);\r\n            const keyVal = item; //TODO keyGetter(item), default return item\r\n\r\n\r\n\r\n            // console.log(\"processElementEach itemElement from exists: \", info.exists.find((ele: Element) => ele[propLiveKeyData]==keyVal && renderElements.indexOf(ele)<0));\r\n            // const itemElement = this.controller.cloneNode(elementInfo.element);\r\n            const itemElement = info.exists.find((ele: Element) => propLiveKeyData in ele && ele[propLiveKeyData] == keyVal && renderElements.indexOf(ele) < 0) as Element ||\r\n                this.controller.cloneNode(elementInfo.element);\r\n            itemElement[propLiveKeyData] = keyVal;\r\n\r\n            const scopeData = { item };\r\n            this.controller.dataManager.pushScopeData(scopeData);\r\n            const itemRenderElements = continueRender(itemElement, info);\r\n            this.controller.dataManager.popScopeData(scopeData);\r\n\r\n            if (itemRenderElements.length > 0)\r\n                renderElements.push(itemRenderElements[0]);\r\n        }\r\n\r\n        return renderElements;\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementIf extends Directive\r\n{\r\n    public static create(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig): DirectiveElementIf\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return null;\r\n\r\n        const attrInfo = info.attrs[config.attr];\r\n\r\n        element.removeAttribute(config.attr);\r\n        delete info.attrs[config.attr];\r\n\r\n        return new DirectiveElementIf(controller, element, attrInfo);\r\n    }\r\n\r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n\r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n\r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        const elementInfo = info.elementInfo;\r\n        // const directiveAttrInfo = elementInfo.directiveAttrs[attrLiveEach];\r\n        const val = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        if (val)\r\n            return continueRender(element, info);\r\n\r\n        return [];\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementRender extends Directive\r\n{\r\n    public static create(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig): DirectiveElementRender\r\n    {\r\n        return new DirectiveElementRender(controller);\r\n    }\r\n\r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementRender renderNode:\", element, info);\r\n        const elementInfo = info.elementInfo;\r\n\r\n        for (const attrName in elementInfo.attrs)\r\n        {\r\n            // if has custom element and xxxxx()\r\n            // else if attrVal != attr.value\r\n            const attrInfo = elementInfo.attrs[attrName];\r\n            const attrVal = attrInfo.exec(this.controller.dataManager.data);\r\n            // renderInfo.attrsVal[attrName] = attrVal;\r\n            element.setAttribute(attrName, attrVal);\r\n        }\r\n\r\n        this.controller.renderChildNodes(element);\r\n\r\n        return continueRender(element, info);\r\n    }\r\n}\r\n","\r\n\r\nexport interface DomScannerOptions\r\n{\r\n    elementStart(element: Element): void;\r\n    elementEnd(element: Element): void;\r\n    comment(comment: Comment): void;\r\n    text(text: Text): void;\r\n    completed() : void;\r\n}\r\n\r\nexport abstract class DomScanner\r\n{\r\n    protected doc: Document;\r\n    protected observer: MutationObserver;\r\n    protected options: DomScannerOptions;\r\n    protected ignoreElementTags = {script: true, style: true};\r\n\r\n    public constructor(doc: Document, options: DomScannerOptions)\r\n    {\r\n        this.options = options;\r\n        this.doc = doc;\r\n        this.observer = new MutationObserver(this.mutationObserverCallback.bind(this));\r\n    }\r\n\r\n    public abstract scan(): Promise<void>;\r\n\r\n    private mutationObserverCallback(mutationList: MutationRecord[])\r\n    {\r\n        // console.log(\"mutationObserverCallback:\", mutationList);\r\n        // push into loading queue\r\n    }\r\n}\r\n","import { DomScanner } from \"./DomScanner\";\r\n\r\nexport class DomScannerLoaded extends DomScanner\r\n{\r\n    protected scanPromise: Promise<void> = null;\r\n\r\n    public scan(): Promise<void>\r\n    {\r\n        if (this.scanPromise)\r\n            return this.scanPromise;\r\n\r\n        return this.scanPromise = new Promise<void>((resolve, reject) =>\r\n        {\r\n            if (this.doc.readyState == \"complete\")\r\n            {\r\n                this.walkNode(this.doc.documentElement);\r\n                this.options.completed();\r\n                this.observer.observe(this.doc.documentElement, { subtree: true, childList: true, attributes: true, characterData: true });\r\n                resolve();\r\n            }\r\n\r\n            else\r\n            {\r\n                this.doc.addEventListener(\"DOMContentLoaded\", () =>\r\n                {\r\n                    this.walkNode(this.doc.documentElement);\r\n                    this.options.completed();\r\n                    this.observer.observe(this.doc.documentElement, { subtree: true, childList: true, attributes: true, characterData: true });\r\n                    resolve();\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    protected walkNode(node: Node)\r\n    {\r\n        // console.log(\"walk node:\", node, this.isCompletedNode(node));\r\n        switch (node.nodeType)\r\n        {\r\n            case 1: //ELEMENT_NODE\r\n                this.processElement(node as Element);\r\n                break;\r\n            case 3: //TEXT_NODE\r\n                this.processText(node as Text);\r\n                break;\r\n            // case 4: //CDATA_SECTION_NODE\r\n            //     if(childInfo = initText(controller, node as Text))\r\n            //     {\r\n            //         info.watch = info.watch.concat(childInfo.watch);\r\n            //     }\r\n            //     break;\r\n            case 8: //COMMENT_NODE\r\n                this.processComment(node as Comment);\r\n                break;\r\n            // default : //Not support type\r\n            //     break;\r\n        }\r\n\r\n    }\r\n\r\n    protected processElement(element: Element)\r\n    {\r\n        // console.log(\"process element:\", element);\r\n        if (this.ignoreElementTags[element.tagName.toLowerCase()])\r\n            return;\r\n\r\n        // if(this.incompleteNodes.indexOf(element) < 0)\r\n        this.processElementStart(element);\r\n\r\n        element.childNodes.forEach((node: Node) =>\r\n        {\r\n            this.walkNode(node);\r\n        });\r\n\r\n        this.processElementEnd(element);\r\n    }\r\n\r\n    protected processElementStart(element: Element)\r\n    {\r\n        // console.log(\"processElementStart:\", element);\r\n        this.options.elementStart(element);\r\n    }\r\n    protected processElementEnd(element: Element)\r\n    {\r\n        // console.log(\"processElementEnd:\", element);\r\n        this.options.elementEnd(element);\r\n    }\r\n    protected processComment(node: Comment)\r\n    {\r\n        // console.log(\"processComment:\", node);\r\n        this.options.comment(node);\r\n    }\r\n    protected processText(node: Text)\r\n    {\r\n        // console.log(\"processText:\", node);\r\n        this.options.text(node);\r\n    }\r\n}\r\n","import { Page, PageOptions } from \"./Page\";\r\nimport { PageController } from \"./PageController\";\r\n\r\n\r\nexport type MapObject<T=any> = {[k: string]: T};\r\nexport type TypeData = {[k: string]: any};\r\nexport type TextFunction<R=any> = (data: TypeData) => R;\r\nexport type RendererFunction<R=any> = (node: Node) => R;\r\n\r\nexport default class LiveDom\r\n{\r\n    public static init(options: PageOptions = {}) : Promise<Page>\r\n    {\r\n        const controller = new PageController(document, options); //TODO singleton for page, and life in doc\r\n        \r\n        return controller.parse().then(() => controller.page);\r\n    }\r\n}\r\n\r\n","import { TypeData } from \"./LiveDom\";\r\n\r\n\r\nexport interface PageOptions\r\n{\r\n    // container?: Element|string;\r\n    data?: TypeData; //init data\r\n    // directives?: MapObject<DirectiveOptions>;\r\n    // debug?: boolean;\r\n}\r\n\r\nexport class Page\r\n{\r\n    public updateData: (data: TypeData) => Promise<void>;\r\n}\r\n\r\n","import { MapObject, TypeData, TextFunction } from \"./LiveDom\";\r\nimport { DomScanner } from \"./DomScanner\";\r\nimport { DomScannerLoaded } from \"./DomScannerLoaded\";\r\nimport { Page, PageOptions } from \"./Page\";\r\nimport { Directive, DirectiveConfig } from \"./Directive\";\r\nimport { DirectiveElementRender } from \"./DirectiveElementRender\";\r\nimport { DirectiveElementEach } from \"./DirectiveElementEach\";\r\nimport { DataManager } from \"./DataManager\";\r\nimport { DirectiveElementIf } from \"./DirectiveElementIf\";\r\nimport { Parser } from \"./Parser\";\r\nimport { AttrInfo, ElementRenderInfo, NodeElementInfo, NodeInfo, NodeTextInfo } from \"./NodeInfo\";\r\n\r\n// 1. scan and observe\r\n// 2. build\r\n// 3. render\r\n\r\n\r\n// <!--\\ld...--><!--/ld-->\r\n// <tag live-dom=\"id1234\"></tag>\r\n// <tag _ld=\"id1234\"></tag>\r\n// <!--_ld=id1234-->\r\n\r\n// .toRawHtml()\r\n\r\n// WeakMap<Document, Map<NodeInfo>>\r\n\r\nconst propLiveInfo = Symbol(\"LiveDomInfoProp\");\r\nconst attrLiveName = \"_ld\";\r\nconst attrLiveEach = \"live:each\";\r\nconst attrLiveIf = \"live:if\";\r\nconst attrLiveElse = \"live:else\";\r\nlet nextId = 1001;\r\n\r\nexport class PageController\r\n{\r\n    public doc: Document;\r\n    public options: PageOptions;\r\n    public page: Page;\r\n    // public container: Element;\r\n    public dataManager: DataManager;\r\n    \r\n    private scanner: DomScanner;\r\n    private elementDirectivesConfig: DirectiveConfig[];\r\n    // private directiveText: DirectiveText;\r\n    private nodeInfos: MapObject<NodeInfo>;\r\n    \r\n    public constructor(doc: Document, options: PageOptions)\r\n    {\r\n        this.doc = doc;\r\n        this.options = options;\r\n        this.dataManager = new DataManager(options.data || {});\r\n        this.elementDirectivesConfig = [\r\n            {attr: attrLiveEach, create: DirectiveElementEach.create, },\r\n            {attr: attrLiveIf, create: DirectiveElementIf.create, },\r\n            {attr: null, create: DirectiveElementRender.create, },\r\n        ];\r\n        // this.directiveText = new DirectiveText();\r\n        this.nodeInfos = {};\r\n        \r\n        this.scanner = new DomScannerLoaded(document, {\r\n            elementStart: this.scanElementStart.bind(this),\r\n            elementEnd: this.scanElementEnd.bind(this),\r\n            comment: this.scanComment.bind(this),\r\n            text: this.scanText.bind(this),\r\n            completed: this.scanCompleted.bind(this),\r\n        });\r\n        this.scanner.scan();\r\n        \r\n        // this.container = options.container as Element;\r\n        // this.page = new Page(this.container);\r\n        this.initPage();\r\n        \r\n        // this.getNodeInfo(this.container).render(this.data);\r\n    }\r\n    \r\n    private initPage()\r\n    {\r\n        this.page = new Page();\r\n        this.page.updateData = this.updatePageData.bind(this);\r\n    }\r\n    private updatePageData(data: TypeData = {}) : Promise<void>\r\n    {\r\n        // console.log(\"updatePageData:\", data);\r\n        this.dataManager.mergePageData(data);\r\n        this.renderElement(this.doc.documentElement);\r\n        return Promise.resolve();\r\n    }\r\n    \r\n    public parse()\r\n    {\r\n        return this.scanner.scan();\r\n    }\r\n    \r\n    private scanElementStart(element: Element) : void\r\n    {\r\n        // init element\r\n        // console.log(\"elementStart:\", element);\r\n        this.setupElement(element);\r\n    }\r\n    private scanElementEnd(element: Element) : void\r\n    {\r\n        // this.renderElement(element);\r\n    }\r\n    private scanComment(comment: Comment) : void\r\n    {\r\n        // console.log(\"comment:\", comment);\r\n    }\r\n    private scanText(text: Text) : void\r\n    {\r\n        // console.log(\"text:\", text);\r\n        \r\n        this.setupText(text);\r\n    }\r\n    private scanCompleted() : void\r\n    {\r\n        this.renderElement(this.doc.documentElement);\r\n    }\r\n    \r\n    private setupElement(element: Element)\r\n    {\r\n        const info: NodeElementInfo = {\r\n            id: 'LDE'+(nextId++),\r\n            element,\r\n            placeholderComment: null,\r\n            attrs: {},\r\n            directives: [],\r\n            directiveAttrs: {},\r\n        };\r\n        \r\n        // console.log(\"DirectiveElement build node:\", nodeInfo, node);\r\n        //TODO find directive attributes and remove, then for each attributes\r\n        const attrs = element.attributes;\r\n        for(let i=attrs.length-1; i>=0; --i)\r\n        {\r\n            const attr = attrs[i];\r\n            const attrInfo = this.setupAttribute(attr);\r\n            // console.log(\"initElement attribute:\", attr, attrInfo);\r\n            if(attrInfo)\r\n            {\r\n                info.attrs[attr.name] = attrInfo;\r\n                // attr.value = attrInfo.exec(this.data);\r\n            }\r\n        }\r\n        \r\n        this.setupElementDirectives(element, info);\r\n        \r\n        if(Object.keys(info.attrs).length == 0 && Object.keys(info.directives).length == 0 && Object.keys(info.directiveAttrs).length == 0)\r\n        {\r\n            this.setNodeInfo(element, null);\r\n            return ;\r\n        }\r\n        \r\n        info.render = this.renderElement.bind(this);\r\n        this.setNodeInfo(element, info);\r\n    }\r\n    private setupElementDirectives(element: Element, info: NodeElementInfo)\r\n    {\r\n        for(const config of this.elementDirectivesConfig)\r\n        {\r\n            const directive = config.create(this, element, info, config);\r\n            if(directive)\r\n                info.directives.push(directive);\r\n        }\r\n    }\r\n    private setupAttribute(attr: Attr) : AttrInfo\r\n    {\r\n        const parseResult = Parser.parseText(attr.value);\r\n        if(!Parser.hasTextExpress(parseResult))\r\n            return null;\r\n        \r\n        return {\r\n            exec: parseResult.exec,\r\n        };\r\n    }\r\n    private renderElement(placeholder: Element)\r\n    {\r\n        const elementInfo = this.getNodeInfo(placeholder) as NodeElementInfo;\r\n        // const element = placeholder.nodeType==1 ? placeholder as Element : elementInfo.element;\r\n        // console.log(\"renderElement:\", placeholder, this.isLiveNode(placeholder), elementInfo);\r\n        if(! elementInfo)\r\n        {\r\n            this.renderChildNodes(placeholder);\r\n            return ;\r\n        }\r\n        \r\n        const exists: Node[] = [placeholder];\r\n        let nextNode = placeholder.nextSibling;\r\n        while(nextNode)\r\n        {\r\n            const nextInfo = this.getNodeInfo(nextNode);\r\n            if(nextInfo != elementInfo)\r\n                break;\r\n            \r\n            exists.push(nextNode);\r\n            nextNode = nextNode.nextSibling;\r\n        }\r\n        \r\n        const renderInfo: ElementRenderInfo = {\r\n            elementInfo,\r\n            exists,\r\n            renders: [], //TODO no use\r\n            attrsVal: {}, //TODO no use\r\n            directivesVal: {},\r\n        };\r\n        \r\n        const element = placeholder.nodeType==1 ? placeholder as Element : elementInfo.element;\r\n        // const renderElements = this.processElementRender(element, renderInfo);\r\n        const renderElements = this.processElementDirectiveRender(element, renderInfo, 0);\r\n        // console.log(\"renderElement renderElements:\", element, renderElements, renderInfo);\r\n        if(renderElements.length == 0)\r\n        {\r\n            // console.log(\"renderElement renderElements remove:\", exists.length, element.parentNode, element);\r\n            const placeholderComment = this.getPlaceholderComment(elementInfo);\r\n            insertAfter(placeholder, placeholderComment);\r\n            for(const ele of exists)\r\n            {\r\n                // console.log(\">>>>>>>>>>>>>>>>>>>>>>>>\", ele.parentNode, ele);\r\n                if(ele != placeholderComment)\r\n                    removeNode(ele);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            let prev = placeholder;\r\n            for(const ele of renderElements)\r\n            {\r\n                insertAfter(prev, ele);\r\n                prev = ele;\r\n            }\r\n            \r\n            for(const ele of exists)\r\n            {\r\n                if(renderElements.indexOf(ele as Element) < 0)\r\n                    removeNode(ele);\r\n            }\r\n        }\r\n    }\r\n    private processElementDirectiveRender(element: Element, renderInfo: ElementRenderInfo, directiveIndex: number) : Element[]\r\n    {\r\n        const directives = renderInfo.elementInfo.directives;\r\n        \r\n        if(directiveIndex < directives.length)\r\n        {\r\n            return directives[directiveIndex].render(\r\n                element,\r\n                renderInfo, \r\n                (ele: Element, info: ElementRenderInfo) => this.processElementDirectiveRender(ele, info, directiveIndex+1)\r\n            );\r\n        }\r\n        \r\n        return [element];\r\n    }\r\n    private getPlaceholderComment(info: NodeElementInfo) : Comment\r\n    {\r\n        if(info.placeholderComment)\r\n            return info.placeholderComment;\r\n        \r\n        info.placeholderComment = this.doc.createComment(\"_LiveDomId=\"+info.id);\r\n        this.setNodeInfo(info.placeholderComment, info);\r\n        return info.placeholderComment;\r\n    }\r\n    public renderChildNodes(parentNode: Node)\r\n    {\r\n        const t = nextId ++;\r\n        const nodes = [];\r\n        const l = parentNode.childNodes.length;\r\n        for(let i=0; i<l; ++i)\r\n            nodes.push(parentNode.childNodes[i]);\r\n        \r\n        for(let i=0; i<l; ++i)\r\n        {\r\n            const node = nodes[i];\r\n            const info = this.getNodeInfo(node);\r\n            if(!info)\r\n            {\r\n                if(node.nodeType == 1) // 1: Node.ELEMENT_NODE\r\n                    this.renderChildNodes(node);\r\n                continue;\r\n            }\r\n            \r\n            if(info._t == t)\r\n                continue;\r\n            \r\n            info.render(node);\r\n            info._t = t;\r\n        }\r\n    }\r\n    \r\n    private setupText(text: Text)\r\n    {\r\n        const parseResult = Parser.parseText(text.data);\r\n        // console.log(\"buildNode parseText:\", parseResult, parseResult.exec({}));\r\n        if(!Parser.hasTextExpress(parseResult))\r\n            return ;\r\n        \r\n        const info: NodeTextInfo = {\r\n            id: 'LDT'+(nextId++),\r\n        };\r\n        \r\n        // console.log(\"buildNode:\", info, text);\r\n        info.render = (node: Text) =>\r\n        {\r\n            node.data = parseResult.exec(this.dataManager.data);\r\n        }\r\n        this.setNodeInfo(text, info);\r\n        // info.render(text);\r\n    }\r\n    \r\n    public cloneNode<N extends Node>(src: N): N\r\n    {\r\n        const des = src.cloneNode(true);\r\n        this.cloneNodesInfo([src], [des]);\r\n        return des as N;\r\n    }\r\n    private cloneNodesInfo(srcNodes: Node[]|NodeListOf<ChildNode>, desNodes: Node[]|NodeListOf<ChildNode>)\r\n    {\r\n        for(let i=0, l=srcNodes.length; i < l; ++i)\r\n        {\r\n            desNodes[i][propLiveInfo] = srcNodes[i][propLiveInfo];\r\n            \r\n            if(srcNodes[i].nodeType == 1) // 1: Node.ELEMENT_NODE\r\n                this.cloneNodesInfo(srcNodes[i].childNodes, desNodes[i].childNodes);\r\n        }\r\n    }\r\n    \r\n    private setNodeInfo(node: Node, info: NodeInfo)\r\n    {\r\n        //weak map ?\r\n        //prop map ?\r\n        node[propLiveInfo] = info;\r\n    }\r\n    private getNodeInfo(node: Node) : NodeInfo\r\n    {\r\n        return node[propLiveInfo] || null;\r\n    }\r\n    private hasNodeInfo(node: Node) : boolean\r\n    {\r\n        return !!node[propLiveInfo];\r\n    }\r\n    private isLiveNode(node: Node) : boolean\r\n    {\r\n        return propLiveInfo in node;\r\n    }\r\n}\r\n\r\n\r\nfunction removeNode(node: Node)\r\n{\r\n    if(node.parentNode)\r\n        node.parentNode.removeChild(node);\r\n}\r\n\r\nfunction insertAfter(before: Node, node: Node)\r\n{\r\n    // console.log(\"insertAfter:\", before, node, before==node, !!before.nextSibling, !!node.parentNode);\r\n    if(before == node)\r\n        return ;\r\n    else if(before.nextSibling)\r\n        before.parentNode.insertBefore(node, before.nextSibling);\r\n    else\r\n        before.parentNode.appendChild(node);\r\n}\r\n\r\n","import { TextFunction, TypeData } from \"./LiveDom\";\r\n\r\n\r\ninterface ParseTextResult\r\n{\r\n    // vars: string[];\r\n    parts: (string|TextFunction)[];\r\n    exec(data: TypeData);\r\n}\r\n\r\nexport class Parser\r\n{\r\n    \r\n    public static parseText(text: string) : ParseTextResult\r\n    {\r\n        const expressionRegex = /\\$\\{\\s*([a-zA-z_]\\w*(\\.\\w+)*)\\s*\\}/g;\r\n        // console.log(\"parseText:\", text.length, text.match(expressionRegex));\r\n        const parts: (string|TextFunction)[] = [];\r\n        let match: RegExpExecArray = null;\r\n        let lastIndex = 0;\r\n        \r\n        while(match = expressionRegex.exec(text))\r\n        {\r\n            if(lastIndex < match.index)\r\n                parts.push(text.substring(lastIndex, match.index));\r\n            \r\n            // console.log(\"parseText result:\", result, expressionRegex.lastIndex);\r\n            const names = match[1].split(/\\./g);\r\n            parts.push(buildTextFunction(names));\r\n            \r\n            lastIndex = expressionRegex.lastIndex;\r\n        }\r\n        \r\n        if(lastIndex < text.length)\r\n            parts.push(text.substring(lastIndex, text.length));\r\n        // console.log(\"parseText lastIndex:\", expressionRegex.lastIndex, parts);\r\n        \r\n        return {parts, exec: buildParseResultRenderer(parts)};\r\n    }\r\n\r\n    public static hasTextExpress(result: ParseTextResult)\r\n    {\r\n        if(result.parts.length > 1)\r\n            return true;\r\n        \r\n        return result.parts.length == 1 && typeof(result.parts[0]) != \"string\";\r\n    }\r\n}\r\n\r\n\r\n// function getWatchVars(info: ParseTextExpressionInfo): string[]\r\n// {\r\n//     // return [info.var.replace(/\\s*\\.\\s*/g, \".\")];\r\n//     return info.var.split(/\\s*\\.\\s*/, 1).slice(0, 1);\r\n// }\r\n\r\nfunction buildTextFunction(names: string[]) : TextFunction\r\n{\r\n    let lastNamePath = \"\";\r\n    let namesPath = names.map((name) =>\r\n    {\r\n        lastNamePath = lastNamePath + \".\" + name;\r\n        return lastNamePath.substring(1);\r\n    });\r\n    \r\n    // let body = \"return data\" + names.map(name => '[\"'+name+'\"]').join(\"\") + \";\";\r\n    let body = `var ${names[0]}=data.${names[0]}; `\r\n            + `return (${namesPath.map(p => `${p}!==null&&${p}!==void 0`).join(\" && \")}) ? ${names.join(\".\")} : null;`;\r\n    \r\n    // console.log(\"buildTextRenderer:\", names, namesPath, body);\r\n    return new Function(\"data\", body) as TextFunction;\r\n}\r\n\r\nfunction buildParseResultRenderer(parts: (string|TextFunction)[])\r\n{\r\n    if(parts.length == 1 && typeof(parts[0]) == \"function\")\r\n    {\r\n        return parts[0];\r\n    }\r\n    \r\n    if(parts.length == 1 && typeof(parts[0]) == \"string\")\r\n    {\r\n        const text = parts[0];\r\n        return function() { return text; };\r\n    }\r\n    \r\n    return function(data: TypeData)\r\n    {\r\n        const results: string[] = [];\r\n        for(const p of parts)\r\n        {\r\n            if(typeof(p) == \"string\")\r\n                results.push(p);\r\n            else\r\n                results.push(p(data));\r\n        }\r\n        \r\n        // console.log(\"textNodeRenderer results:\", results, data);\r\n        return results.join(\"\");\r\n    };\r\n}\r\n\r\n\r\n\r\n","import LiveDom from \"./LiveDom\";\r\n\r\n// console.log(\">>>>>>>>>>>>> LiveDom:\", LiveDom);\r\n\r\n// export function testLiveDom()\r\n// {\r\n//     console.log(\">>>>>>>>>>>>> testLiveDom:\", LiveDom);\r\n    \r\n// }\r\n\r\n// window[\"LiveDom\"] = LiveDom;\r\n\r\nexport = LiveDom;\r\n"]}