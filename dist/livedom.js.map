{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/DataManager.ts","src/Directive.ts","src/DirectiveDisableChildNodes.ts","src/DirectiveElementEach.ts","src/DirectiveElementElse.ts","src/DirectiveElementIf.ts","src/DirectiveElementInnerHtml.ts","src/DirectiveElementInnerText.ts","src/DirectiveElementRender.ts","src/DirectiveHtmlInputRender.ts","src/DirectiveHtmlTemplate.ts","src/DomScanner.ts","src/DomScannerLoaded.ts","src/LiveDom.ts","src/Page.ts","src/PageController.ts","src/Parser.ts","src/main.ts"],"names":["f","exports","module","define","amd","window","global","self","this","LiveDom","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","DataManager","initData","topData","scopeDataStack","lastMergeData","pageData","Object","create","data","mergePageData","prototype","newData","assign","commitMergeData","hasUseLastMergeData","paths","pushScopeData","scopeData","push","popScopeData","pop","getPrototypeOf","Directive","controller","hasDirective","_info","info","directives","Array","isArray","_i","_a","_super","Directive_1","DirectiveDisableChildNodes","__extends","setup","element","config","val","hasAttribute","attr","attrs","directive","getAttribute","disableChildNodes","toLowerCase","removeAttribute","render","continueRender","attrInfo","propLiveKeyData","Symbol","DirectiveElementEach","itemName","indexName","nodeInfo","items","exec","dataManager","renderElements","l","item","keyVal","itemElement","_b","exists","ele","indexOf","cloneNode","srcElement","renderInfo","__assign","getRenderInfo","itemRenderElements","_this","DirectiveElementEach_1","DirectiveElementIf_1","DirectiveElementElse","prevNode","previousSibling","isPlaceholder","prevNodeInfo","getNodeInfo","DirectiveElementIf","nodeType","DirectiveElementInnerHtml","innerHTML","DirectiveElementInnerText","innerText","DirectiveElementRender","keys","disableRenderChildNodes","attrName","attrVal","setAttribute","lastAttrsVal","renderChildNodes","DirectiveHtmlInputRender","tagName","toLocaleLowerCase","value","checked","DirectiveHtmlTemplate","templateId","template","ownerDocument","getElementById","content","shadow","shadowRoot","attachShadow","mode","appendChild","DomScanner","doc","options","ignoreElementTags","script","style","observer","MutationObserver","mutationObserverCallback","bind","startObserve","observe","documentElement","subtree","childList","attributes","records","records_1","record","type","attrChanged","target","attributeName","addedNodes","forEach","node","walkNode","DomScanner_1","DomScannerLoaded","scan","scanPromise","Promise","resolve","reject","readyState","addEventListener","processElement","processText","processComment","processElementStart","processChildNodes","processElementEnd","childNodes","elementStart","elementEnd","comment","text","apply","arguments","DirectiveDisableChildNodes_1","DirectiveElementElse_1","DirectiveElementInnerHtml_1","DirectiveElementInnerText_1","DirectiveElementRender_1","DirectiveHtmlInputRender_1","DirectiveHtmlTemplate_1","Page_1","PageController_1","initPage","controllerOptions","elementDirectivesConfig","PageController","document","createPage","page","Page","updateData","updatePageData","DomScannerLoaded_1","Parser_1","DataManager_1","propNodeInfo","propRenderInfo","nextId","scanCompletedPromise","requestRenderPagePromise","scanner","scanElementStart","scanElementEnd","scanComment","scanText","onAttrChanged","then","onPageSetupCompleted","requestRenderPage","removeNode","parentNode","removeChild","insertAfter","before","nextSibling","insertBefore","ms","setTimeout","renderElement","isLiveNode","setupElement","setupText","newVal","srcVal","updateAttribute","setupElementDirectives","createAttribute","id","setupElementAttributes","setNodeInfo","name","parseResult","Parser","parseText","hasTextExpress","lastVal","nextNode","processElementDirectiveRender","placeholderComment","getPlaceholderComment","exists_1","prev","renderElements_1","exists_2","directiveIndex","ri","setRenderInfo","createComment","nodes","_t","textExec","src","des","cloneNodesInfo","srcNodes","desNodes","hasNodeInfo","hasRenderInfo","expressionRegex","parts","match","lastIndex","index","substring","names","split","lastNamePath","namesPath","map","body","concat","join","Function","buildTextFunction","results","parts_1","text_1","buildParseResultRenderer","result","LiveDom_1","default"],"mappings":"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","file":"livedom.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\r\nexport type TypeData = {[k: string]: any};\r\nexport type DataPaths = {[path: string]: string[]};\r\n\r\nexport class DataManager\r\n{\r\n    public data: TypeData;\r\n    public topData: TypeData;\r\n    public pageData: TypeData;\r\n    public lastMergeData: TypeData;\r\n    private scopeDataStack: TypeData[];\r\n    \r\n    public constructor(initData: TypeData)\r\n    {\r\n        this.topData = {};\r\n        this.scopeDataStack = [];\r\n        this.lastMergeData = {};\r\n        \r\n        this.pageData = Object.create(this.topData);\r\n        this.data = Object.create(this.pageData);\r\n        \r\n        this.mergePageData(initData);\r\n    }\r\n    \r\n    public mergePageData(newData: TypeData)\r\n    {\r\n        Object.assign(this.lastMergeData, newData);\r\n        Object.assign(this.pageData, newData);\r\n    }\r\n    public commitMergeData() //like transaction commit\r\n    {\r\n        this.lastMergeData = {};\r\n    }\r\n    public hasUseLastMergeData(paths: DataPaths): boolean\r\n    {\r\n        for(const p in paths)\r\n        {\r\n            if(paths[p][0] in this.lastMergeData)\r\n                return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    // public hasUseLastMergeDataDeep(paths: DataPaths): boolean\r\n    // {\r\n    // }\r\n    \r\n    public pushScopeData(scopeData: TypeData)\r\n    {\r\n        this.scopeDataStack.push(scopeData);\r\n        this.data = Object.create(this.data);\r\n        Object.assign(this.data, scopeData);\r\n    }\r\n    public popScopeData(scopeData: TypeData)\r\n    {\r\n        if (this.scopeDataStack[this.scopeDataStack.length - 1] != scopeData)\r\n            throw new Error(\"popScopeData fail! scopeData not last data.\");\r\n        \r\n        this.scopeDataStack.pop();\r\n        this.data = Object.getPrototypeOf(this.data);\r\n    }\r\n}\r\n","import { PageController } from \"./PageController\";\r\nimport { ElementRenderInfo, NodeElementInfo, NodeInfo } from \"./NodeInfo\";\r\n\r\nexport interface DirectiveConfig<N extends Node = Node>\r\n{\r\n    attr?: string;\r\n    setup: (controller: PageController, node: N, info: NodeInfo, config: DirectiveConfig<N>)=>void;\r\n}\r\n\r\nexport interface DirectiveRender<N extends Node = Node>\r\n{\r\n    (element: N, renderInfo: ElementRenderInfo): N[];\r\n}\r\n// class DirectiveText extends Directive\r\n// {\r\n// }\r\n\r\n\r\nexport abstract class Directive<N extends Node = Node>\r\n{\r\n    public static hasDirective(_info: NodeInfo) : boolean\r\n    {\r\n        const info = _info as NodeElementInfo;\r\n        \r\n        if(!info.directives || !Array.isArray(info.directives))\r\n            return false;\r\n        \r\n        for(const d of info.directives)\r\n        {\r\n            if(d instanceof this)\r\n                return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    // public name: string = null;\r\n    // public abstract buildNode(nodeInfo: NodeInfo, node: Node);\r\n    public abstract render(element: N, renderInfo: ElementRenderInfo, continueRender: DirectiveRender<N>): N[];\r\n    // public abstract unsetNode(nodeInfo: NodeInfo);\r\n    protected controller: PageController;\r\n    protected constructor(controller: PageController)\r\n    {\r\n        this.controller = controller;\r\n    }\r\n}\r\n\r\n// class DirectiveElementStateClass extends Directive //live-state=\"rendering|complete\"\r\n// {\r\n// }\r\n// class DirectiveElementContent extends Directive //live:cont\r\n// {\r\n// }\r\n\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\n//TODO 优化不进内部进行setup, 但如果值是动态的话, 可能会引起错误或复杂性\r\n//TODO 如果只对内部渲染时, 可能会忽略了这个设置, 可以在开始渲染标签时先检查这个标签是否在禁止标签里\r\n\r\nexport class DirectiveDisableChildNodes extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if (!element.hasAttribute(config.attr))\r\n            return ;\r\n        \r\n        const attrInfo = info.attrs[config.attr];\r\n        const directive = new DirectiveDisableChildNodes(controller, element, attrInfo);\r\n        const val = element.getAttribute(config.attr) || \"true\";\r\n        info.disableChildNodes = (val.toLowerCase() != \"false\");\r\n        element.removeAttribute(config.attr);\r\n        // info.attrs[config.attr].directive = directive;\r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    // private element: Element;\r\n    // private attrInfo: AttrInfo;\r\n    \r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        // this.attrInfo = attrInfo;\r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        // const elementInfo = info.nodeInfo;\r\n        // const directiveAttrInfo = elementInfo.directiveAttrs[attrLiveEach];\r\n        // const val = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        \r\n        return continueRender(element, info);\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nconst propLiveKeyData = Symbol(\"LiveDomKeyDataProp\");\r\n\r\nexport class DirectiveElementEach extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return ;\r\n        \r\n        const attrInfo = info.attrs[config.attr];\r\n        const directive = new DirectiveElementEach(controller, element, attrInfo);\r\n        \r\n        element.removeAttribute(config.attr);\r\n        info.attrs[config.attr].directive = directive;\r\n        \r\n        if(element.hasAttribute(\"live:item\"))\r\n        {\r\n            directive.itemName = element.getAttribute(\"live:item\");\r\n            element.removeAttribute(\"live:item\");\r\n        }\r\n        \r\n        if(element.hasAttribute(\"live:index\"))\r\n        {\r\n            directive.indexName = element.getAttribute(\"live:index\");\r\n            element.removeAttribute(\"live:index\");\r\n        }\r\n        \r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n    private itemName: string = \"item\";\r\n    private indexName: string = \"index\";\r\n    \r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        const nodeInfo = info.nodeInfo;\r\n        // const directiveAttrInfo = elementInfo.directiveAttrs[attrLiveEach];\r\n        const items = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        // info.directivesVal[attrLiveEach] = items;\r\n        \r\n        if(!Array.isArray(items) || items.length == 0)\r\n            return [];\r\n        \r\n        let renderElements: Element[] = [];\r\n        for(let i=0, l=items.length; i<l; ++i)\r\n        {\r\n            const item = items[i];\r\n            // console.log(\"DirectiveElementEach item:\", item);\r\n            const keyVal = item; //TODO keyGetter(item), default return item\r\n            \r\n            // console.log(\"processElementEach itemElement from exists: \", info.exists.find((ele: Element) => ele[propLiveKeyData]==keyVal && renderElements.indexOf(ele)<0));\r\n            // const itemElement = this.controller.cloneNode(elementInfo.element);\r\n            let itemElement: Element = null;\r\n            for(const ele of info.exists as Element[])\r\n            {\r\n                if(propLiveKeyData in ele && ele[propLiveKeyData] == keyVal && renderElements.indexOf(ele) < 0)\r\n                {\r\n                    // console.log(\"each propLiveKeyData:\", keyVal, ele);\r\n                    itemElement = ele;\r\n                    break;\r\n                }\r\n            }\r\n            if(!itemElement)\r\n                itemElement = this.controller.cloneNode(nodeInfo.srcElement);\r\n            \r\n            const renderInfo: ElementRenderInfo = {\r\n                ...info,\r\n                ...this.controller.getRenderInfo(itemElement) as ElementRenderInfo,\r\n            };\r\n            \r\n            itemElement[propLiveKeyData] = keyVal;\r\n            \r\n            const scopeData = { [this.itemName]: item, [this.indexName]: i };\r\n            this.controller.dataManager.pushScopeData(scopeData);\r\n            const itemRenderElements = continueRender(itemElement, renderInfo);\r\n            this.controller.dataManager.popScopeData(scopeData);\r\n            // console.log(\"itemElement html:\", item, itemElement.innerHTML);\r\n            \r\n            if (itemRenderElements.length > 0)\r\n                renderElements.push(itemRenderElements[0]);\r\n        }\r\n        \r\n        return renderElements;\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { DirectiveElementEach } from \"./DirectiveElementEach\";\r\nimport { DirectiveElementIf } from \"./DirectiveElementIf\";\r\nimport { NodeElementInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementElse extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if (!element.hasAttribute(config.attr))\r\n            return ;\r\n        \r\n        const directive = new DirectiveElementElse(controller, element);\r\n        element.removeAttribute(config.attr);\r\n        \r\n        if(info.attrs[config.attr])\r\n            info.attrs[config.attr].directive = directive;\r\n        \r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    // private element: Element;\r\n    protected constructor(controller: PageController, element: Element)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementElse renderNode:\", element, element.previousElementSibling, info);\r\n        let prevNode: Node = info.exists[0];\r\n        while(prevNode = prevNode.previousSibling)\r\n        {\r\n            // console.log(\"DirectiveElementElse find prev:\", this.controller.isPlaceholder(prevNode), prevNode);\r\n            if(this.controller.isPlaceholder(prevNode))\r\n            {\r\n                const prevNodeInfo = this.controller.getNodeInfo(prevNode);\r\n                if(DirectiveElementIf.hasDirective(prevNodeInfo) || DirectiveElementEach.hasDirective(prevNodeInfo))\r\n                    return continueRender(element, info);\r\n                \r\n                break;\r\n            }\r\n            \r\n            if(prevNode.nodeType == 1) //1: Node.ELEMENT_NODE\r\n                break;\r\n        }\r\n        \r\n        return [];\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementIf extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return ;\r\n        \r\n        const attrInfo = info.attrs[config.attr];\r\n        const directive = new DirectiveElementIf(controller, element, attrInfo);\r\n        \r\n        element.removeAttribute(config.attr);\r\n        info.attrs[config.attr].directive = directive;\r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n    \r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        // const elementInfo = info.nodeInfo;\r\n        // const directiveAttrInfo = elementInfo.directiveAttrs[attrLiveEach];\r\n        const val = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        if (val)\r\n            return continueRender(element, info);\r\n        \r\n        return [];\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\n//TODO skip setup children\r\n\r\nexport class DirectiveElementInnerHtml extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return ;\r\n        \r\n        const attrInfo = info.attrs[config.attr];\r\n        const directive = new DirectiveElementInnerHtml(controller, element, attrInfo);\r\n        \r\n        info.disableChildNodes = true;\r\n        element.removeAttribute(config.attr);\r\n        info.attrs[config.attr].directive = directive;\r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n    \r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        // const elementInfo = info.nodeInfo;\r\n        const val = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        element.innerHTML = val;\r\n        return continueRender(element, info);\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\n//TODO skip setup children\r\n\r\nexport class DirectiveElementInnerText extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if (!info.attrs[config.attr])\r\n            return ;\r\n        \r\n        const attrInfo = info.attrs[config.attr];\r\n        const directive = new DirectiveElementInnerText(controller, element, attrInfo);\r\n        \r\n        info.disableChildNodes = true;\r\n        element.removeAttribute(config.attr);\r\n        info.attrs[config.attr].directive = directive;\r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    // private element: Element;\r\n    private attrInfo: AttrInfo;\r\n    \r\n    protected constructor(controller: PageController, element: Element, attrInfo: AttrInfo)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrInfo = attrInfo;\r\n    }\r\n    \r\n    public render(element: HTMLElement, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        // const elementInfo = info.nodeInfo;\r\n        const val = this.attrInfo.exec(this.controller.dataManager.data);\r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        element.innerText = val;\r\n        return continueRender(element, info);\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport class DirectiveElementRender extends Directive // rename to DirectiveElementNormalAttributes\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if(Object.keys(info.attrs).length == 0 && info.directives.length == 0)\r\n            return ;\r\n        \r\n        const directive = new DirectiveElementRender(controller);\r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    public static disableRenderChildNodes(renderInfo: ElementRenderInfo)\r\n    {\r\n        \r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementRender renderNode:\", element, info);\r\n        const nodeInfo = info.nodeInfo;\r\n        \r\n        for (const attrName in nodeInfo.attrs)\r\n        {\r\n            // if has custom element and xxxxx()\r\n            // else if attrVal != attr.value\r\n            const attrInfo = nodeInfo.attrs[attrName];\r\n            if(attrInfo.directive)\r\n                continue ;\r\n            \r\n            const attrVal = attrInfo.exec(this.controller.dataManager.data);\r\n            element.setAttribute(attrName, attrVal);\r\n            info.lastAttrsVal[attrName] = attrVal;\r\n        }\r\n        \r\n        // console.log(\">>>>>>>>\", element, nodeInfo.disableChildNodes);\r\n        if(! nodeInfo.disableChildNodes)\r\n            this.controller.renderChildNodes(element);\r\n        \r\n        return continueRender(element, info);\r\n    }\r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, ElementRenderInfo, AttrInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\ntype AttrsInfoMap = {[name: string]: AttrInfo};\r\n\r\nexport class DirectiveHtmlInputRender extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if(element.tagName.toLocaleLowerCase() != \"input\")\r\n            return null;\r\n        \r\n        const attrs: AttrsInfoMap = {};\r\n        \r\n        if(element.hasAttribute(\"value\") && info.attrs.value)\r\n        {\r\n            attrs.value = info.attrs.value;\r\n            element.removeAttribute(\"value\");\r\n            delete info.attrs.value;\r\n        }\r\n        \r\n        if(element.hasAttribute(\"checked\") && info.attrs.checked)\r\n        {\r\n            attrs.checked = info.attrs.checked;\r\n            element.removeAttribute(\"checked\");\r\n            delete info.attrs.checked;\r\n        }\r\n        \r\n        if(Object.keys(attrs).length > 0)\r\n        {\r\n            info.directives.push(new DirectiveHtmlInputRender(controller, element, attrs));\r\n        }\r\n    }\r\n    \r\n    // private element: Element;\r\n    private attrs: AttrsInfoMap;\r\n\r\n    protected constructor(controller: PageController, element: Element, attrs: AttrsInfoMap)\r\n    {\r\n        super(controller);\r\n        // this.element = element;\r\n        this.attrs = attrs;\r\n    }\r\n\r\n    public render(element: HTMLInputElement, info: HtmlInputRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        \r\n        if(this.attrs.value && this.controller.dataManager.hasUseLastMergeData(this.attrs.value.paths))\r\n        {\r\n            //TODO check has use merge data\r\n            const val = this.attrs.value.exec(this.controller.dataManager.data);\r\n            element.setAttribute(\"value\", val);\r\n            element.value = val;\r\n        }\r\n        \r\n        if(this.attrs.checked && this.controller.dataManager.hasUseLastMergeData(this.attrs.checked.paths))\r\n        {\r\n            //TODO check has use merge data\r\n            const val = this.attrs.checked.exec(this.controller.dataManager.data);\r\n            // element.setAttribute(\"value\", val);\r\n            element.checked = !!val;\r\n        }\r\n        \r\n        // console.log(\"DirectiveElementEach items:\", items);\r\n        return continueRender(element, info);\r\n    }\r\n}\r\n\r\ninterface HtmlInputRenderInfo extends ElementRenderInfo\r\n{\r\n    \r\n}\r\n","import { Directive, DirectiveConfig, DirectiveRender } from \"./Directive\";\r\nimport { NodeElementInfo, AttrInfo, ElementRenderInfo } from \"./NodeInfo\";\r\nimport { PageController } from \"./PageController\";\r\n\r\n\r\nexport class DirectiveHtmlTemplate extends Directive\r\n{\r\n    public static setup(controller: PageController, element: Element, info: NodeElementInfo, config: DirectiveConfig)\r\n    {\r\n        if (!element.hasAttribute(config.attr))\r\n            return ;\r\n        \r\n        const attrVal = element.getAttribute(config.attr);\r\n        const attrInfo = info.attrs[config.attr];\r\n        const directive = new DirectiveHtmlTemplate(controller, element);\r\n        directive.attrInfo = attrInfo;\r\n        directive.attrVal = attrVal;\r\n        element.removeAttribute(config.attr);\r\n        \r\n        if(attrInfo)\r\n            attrInfo.directive = directive;\r\n        \r\n        info.directives.push(directive);\r\n    }\r\n    \r\n    private element: Element;\r\n    private attrInfo: AttrInfo;\r\n    private attrVal: string;\r\n    \r\n    protected constructor(controller: PageController, element: Element)\r\n    {\r\n        super(controller);\r\n        this.element = element;\r\n    }\r\n    \r\n    public render(element: Element, info: ElementRenderInfo, continueRender: DirectiveRender<Element>)\r\n    {\r\n        // console.log(\"DirectiveElementEach renderNode:\", element, info);\r\n        // const elementInfo = info.nodeInfo;\r\n        \r\n        const templateId = this.attrInfo ? this.attrInfo.exec(this.controller.dataManager.data) : this.attrVal;\r\n        const template = (element.ownerDocument.getElementById(templateId) as HTMLTemplateElement).content;\r\n        \r\n        const shadow = element.shadowRoot || element.attachShadow({mode: \"open\"});\r\n        shadow.innerHTML = \"\";\r\n        shadow.appendChild(template.cloneNode(true)); //TODO controller.cloneNode()\r\n        \r\n        return continueRender(element, info);\r\n    }\r\n}\r\n","\r\n\r\nexport interface DomScannerOptions\r\n{\r\n    elementStart(element: Element): void;\r\n    elementEnd(element: Element): void;\r\n    comment(comment: Comment): void;\r\n    text(text: Text): void;\r\n    attrChanged(element: Element, attrName: string): void;\r\n    // elementAdd(element: Element): void;\r\n}\r\n\r\nexport abstract class DomScanner\r\n{\r\n    protected doc: Document;\r\n    protected observer: MutationObserver;\r\n    protected options: DomScannerOptions;\r\n    protected ignoreElementTags = {script: true, style: true};\r\n\r\n    public constructor(doc: Document, options: DomScannerOptions)\r\n    {\r\n        this.options = options;\r\n        this.doc = doc;\r\n        this.observer = new MutationObserver(this.mutationObserverCallback.bind(this));\r\n    }\r\n    \r\n    public abstract scan(): Promise<void>;\r\n    protected abstract walkNode(node: Node) : void;\r\n    \r\n    protected startObserve()\r\n    {\r\n        const options: MutationObserverInit = {\r\n            subtree: true,\r\n            childList: true,\r\n            attributes: true,\r\n            // characterData: true,\r\n        };\r\n        this.observer.observe(this.doc.documentElement, options);\r\n    }\r\n    private mutationObserverCallback(records: MutationRecord[])\r\n    {\r\n        // console.log(\"mutationObserverCallback:\", records);\r\n        //TODO setup\r\n        //TODO notify parents update, and rerender\r\n        // updateAttr|Element|Text\r\n        for(const record of records)\r\n        {\r\n            // record.addedNodes.forEach((node) =>\r\n            // {\r\n            //     console.log(\"mutationObserver addedNode:\", node);\r\n            //     if(addedNodes.indexOf(node) < 0)\r\n            //         addedNodes.push(node);\r\n            //     else\r\n            //         console.log(\"mutationObserver addedNode duplicated:\", node);\r\n            // });\r\n            // continue;\r\n            \r\n            // console.log(\"mutationObserver\", record.type, record.target, record.addedNodes, record.removedNodes);\r\n            switch(record.type)\r\n            {\r\n            // case \"characterData\": //don't observe\r\n            //     // if(record.target.nodeType == 3) //TEXT_NODE\r\n            //         this.options.textChanged(record.target as Text);\r\n            //     break;\r\n                \r\n            case \"attributes\":\r\n                // console.log(\"mutationObserver attributes:\", record.attributeName, record.target);\r\n                this.options.attrChanged(record.target as Element, record.attributeName);\r\n                break;\r\n                \r\n            case \"childList\":\r\n                // TODO scan inside\r\n                record.addedNodes.forEach((node) =>\r\n                {\r\n                    this.walkNode(node);\r\n                });\r\n                break;\r\n                \r\n            }\r\n        }\r\n    }\r\n}\r\n","import { DomScanner } from \"./DomScanner\";\r\n\r\nexport class DomScannerLoaded extends DomScanner\r\n{\r\n    protected scanPromise: Promise<void> = null;\r\n\r\n    public scan(): Promise<void>\r\n    {\r\n        if (this.scanPromise)\r\n            return this.scanPromise;\r\n        \r\n        return this.scanPromise = new Promise<void>((resolve, reject) =>\r\n        {\r\n            if (this.doc.readyState == \"complete\")\r\n            {\r\n                this.walkNode(this.doc.documentElement);\r\n                this.startObserve();\r\n                resolve();\r\n            }\r\n            else\r\n            {\r\n                this.doc.addEventListener(\"DOMContentLoaded\", () =>\r\n                {\r\n                    this.walkNode(this.doc.documentElement);\r\n                    this.startObserve();\r\n                    resolve();\r\n                });\r\n            }\r\n        });\r\n    }\r\n    \r\n    protected walkNode(node: Node)\r\n    {\r\n        // console.log(\"walk node:\", node, this.isCompletedNode(node));\r\n        switch (node.nodeType)\r\n        {\r\n            case 1: //ELEMENT_NODE\r\n                this.processElement(node as Element);\r\n                break;\r\n            case 3: //TEXT_NODE\r\n                this.processText(node as Text);\r\n                break;\r\n            // case 4: //CDATA_SECTION_NODE\r\n            //     if(childInfo = initText(controller, node as Text))\r\n            //     {\r\n            //         info.watch = info.watch.concat(childInfo.watch);\r\n            //     }\r\n            //     break;\r\n            case 8: //COMMENT_NODE\r\n                this.processComment(node as Comment);\r\n                break;\r\n            // default : //Not support type\r\n            //     break;\r\n        }\r\n        \r\n    }\r\n    \r\n    protected processElement(element: Element)\r\n    {\r\n        // console.log(\"process element:\", element);\r\n        if (this.ignoreElementTags[element.tagName.toLowerCase()])\r\n            return;\r\n\r\n        // if(this.incompleteNodes.indexOf(element) < 0)\r\n        this.processElementStart(element);\r\n        this.processChildNodes(element);\r\n        this.processElementEnd(element);\r\n    }\r\n    \r\n    protected processChildNodes(element: Element)\r\n    {\r\n        element.childNodes.forEach((node: Node) =>\r\n        {\r\n            this.walkNode(node);\r\n        });\r\n    }\r\n\r\n    protected processElementStart(element: Element)\r\n    {\r\n        // console.log(\"processElementStart:\", element);\r\n        this.options.elementStart(element);\r\n    }\r\n    protected processElementEnd(element: Element)\r\n    {\r\n        // console.log(\"processElementEnd:\", element);\r\n        this.options.elementEnd(element);\r\n    }\r\n    protected processComment(node: Comment)\r\n    {\r\n        // console.log(\"processComment:\", node);\r\n        this.options.comment(node);\r\n    }\r\n    protected processText(node: Text)\r\n    {\r\n        // console.log(\"processText:\", node);\r\n        this.options.text(node);\r\n    }\r\n}\r\n","import { DirectiveDisableChildNodes } from \"./DirectiveDisableChildNodes\";\r\nimport { DirectiveElementEach } from \"./DirectiveElementEach\";\r\nimport { DirectiveElementElse } from \"./DirectiveElementElse\";\r\nimport { DirectiveElementIf } from \"./DirectiveElementIf\";\r\nimport { DirectiveElementInnerHtml } from \"./DirectiveElementInnerHtml\";\r\nimport { DirectiveElementInnerText } from \"./DirectiveElementInnerText\";\r\nimport { DirectiveElementRender } from \"./DirectiveElementRender\";\r\nimport { DirectiveHtmlInputRender } from \"./DirectiveHtmlInputRender\";\r\nimport { DirectiveHtmlTemplate } from \"./DirectiveHtmlTemplate\";\r\nimport { createPage, Page, PageOptions } from \"./Page\";\r\nimport { PageController } from \"./PageController\";\r\n\r\nexport default class LiveDom\r\n{\r\n    public static initPage(options: PageOptions = {}) : Page\r\n    {\r\n        const controllerOptions = {\r\n            ...options,\r\n            elementDirectivesConfig: [\r\n                {attr: \"live:each\", setup: DirectiveElementEach.setup, },\r\n                {attr: \"live:if\", setup: DirectiveElementIf.setup, },\r\n                {attr: \"live:else\", setup: DirectiveElementElse.setup, },\r\n                {attr: null, setup: DirectiveHtmlInputRender.setup, },\r\n                {attr: \"live:html\", setup: DirectiveElementInnerHtml.setup, },\r\n                {attr: \"live:text\", setup: DirectiveElementInnerText.setup, },\r\n                {attr: \"live:template\", setup: DirectiveHtmlTemplate.setup, },\r\n                {attr: \"live:disable-children\", setup: DirectiveDisableChildNodes.setup, },\r\n                {attr: null, setup: DirectiveElementRender.setup, }, //must last one\r\n            ]\r\n        };\r\n        const controller = new PageController(document, controllerOptions);\r\n        return createPage(controller);\r\n    }\r\n}\r\n\r\n","import { TypeData } from \"./DataManager\";\r\nimport { PageController } from \"./PageController\";\r\n\r\n //TODO singleton for page, and life in doc\r\n\r\nexport interface PageOptions\r\n{\r\n    // container?: Element|string;\r\n    data?: TypeData; //init data\r\n    // directives?: MapObject<DirectiveOptions>;\r\n    onPageSetupCompleted?: ()=>void;\r\n    // debug?: boolean;\r\n}\r\n\r\nexport function createPage(controller: PageController) : Page\r\n{\r\n    const page = new Page();\r\n    \r\n    page.updateData = controller.updatePageData.bind(controller);\r\n    \r\n    return page;\r\n}\r\n\r\nexport class Page\r\n{\r\n    public updateData: (data: TypeData) => Promise<void>;\r\n    // public onReady: (callback: ()=>void) => void;\r\n}\r\n\r\n","import { DomScanner } from \"./DomScanner\";\r\nimport { DomScannerLoaded } from \"./DomScannerLoaded\";\r\nimport { Parser } from \"./Parser\";\r\nimport { PageOptions } from \"./Page\";\r\nimport { DataManager, TypeData } from \"./DataManager\";\r\nimport { AttrInfo, ElementRenderInfo, NodeElementInfo, NodeInfo, NodeTextInfo, RenderInfo } from \"./NodeInfo\";\r\nimport { Directive, DirectiveConfig } from \"./Directive\";\r\n\r\nconst propNodeInfo = Symbol(\"LiveDomNodeInfoProp\");\r\nconst propRenderInfo = Symbol(\"LiveDomRenderInfoProp\");\r\n// const attrLiveName = \"_ld\";\r\n// const attrLiveEach = \"live:each\";\r\n// const attrLiveIf = \"live:if\";\r\n// const attrLiveElse = \"live:else\";\r\nlet nextId = 1001;\r\n\r\ninterface PageControllerOptions extends PageOptions\r\n{\r\n    elementDirectivesConfig: DirectiveConfig<Element>[];\r\n}\r\n\r\nexport class PageController\r\n{\r\n    public doc: Document;\r\n    public options: PageOptions;\r\n    public dataManager: DataManager;\r\n    public scanCompletedPromise: Promise<void> = null;\r\n    \r\n    private scanner: DomScanner;\r\n    private elementDirectivesConfig: DirectiveConfig<Element>[];\r\n    // private directiveText: DirectiveText;\r\n    // private nodeInfos: MapObject<NodeInfo>;\r\n    private requestRenderPagePromise: Promise<void> = null;\r\n    \r\n    public constructor(doc: Document, options: PageControllerOptions)\r\n    {\r\n        this.doc = doc;\r\n        this.options = options;\r\n        this.dataManager = new DataManager(this.options.data || {});\r\n        this.elementDirectivesConfig = options.elementDirectivesConfig;\r\n        // this.directiveText = new DirectiveText();\r\n        // this.nodeInfos = {};\r\n        \r\n        this.scanner = new DomScannerLoaded(document, {\r\n            elementStart: this.scanElementStart.bind(this),\r\n            elementEnd: this.scanElementEnd.bind(this),\r\n            comment: this.scanComment.bind(this),\r\n            text: this.scanText.bind(this),\r\n            attrChanged: this.onAttrChanged.bind(this),\r\n        });\r\n        \r\n        this.scanCompletedPromise = this.scanner.scan().\r\n        then(() =>\r\n        {\r\n            if(this.options.onPageSetupCompleted)\r\n                this.options.onPageSetupCompleted();\r\n            \r\n            this.requestRenderPage();\r\n        });\r\n    }\r\n    \r\n    public updatePageData(data: TypeData = {}) : Promise<void>\r\n    {\r\n        // console.log(\"updatePageData:\", data);\r\n        this.dataManager.mergePageData(data);\r\n        return this.requestRenderPage();\r\n    }\r\n    private requestRenderPage() : Promise<void>\r\n    {\r\n        if(this.requestRenderPagePromise)\r\n            return this.requestRenderPagePromise;\r\n        \r\n        return this.requestRenderPagePromise = this.scanCompletedPromise.\r\n        then(() => wait(5)).\r\n        then(() =>\r\n        {\r\n            this.requestRenderPagePromise = null;\r\n            this.renderElement(this.doc.documentElement);\r\n            this.dataManager.commitMergeData();\r\n        });\r\n    }\r\n    \r\n    private scanElementStart(element: Element) : void\r\n    {\r\n        // console.log(\"elementStart:\", element);\r\n        if(this.isLiveNode(element))\r\n            return ;\r\n        \r\n        this.setupElement(element);\r\n    }\r\n    private scanElementEnd(element: Element) : void\r\n    {\r\n        // this.renderElement(element);\r\n    }\r\n    private scanComment(comment: Comment) : void\r\n    {\r\n        // console.log(\"comment:\", comment);\r\n    }\r\n    private scanText(text: Text) : void\r\n    {\r\n        // console.log(\"text:\", text);\r\n        if(this.isLiveNode(text))\r\n            return ;\r\n        \r\n        this.setupText(text);\r\n    }\r\n    \r\n    private onAttrChanged(element: Element, attrName: string)\r\n    {\r\n        const nodeInfo = this.getNodeInfo(element) as NodeElementInfo;\r\n        if(!nodeInfo)\r\n            return this.setupElement(element);\r\n        \r\n        const renderInfo = this.getRenderInfo(element) as ElementRenderInfo;\r\n        const newVal = element.getAttribute(attrName);\r\n        let attrInfo = nodeInfo.attrs[attrName];\r\n        \r\n        if(!attrInfo) // not live attr\r\n        {\r\n            if(newVal && (attrInfo = this.createAttribute(newVal)))\r\n            {\r\n                nodeInfo.attrs[attrName] = attrInfo;\r\n                this.setupElementDirectives(element, nodeInfo);\r\n            }\r\n            return ;\r\n        }\r\n        \r\n        if(newVal == renderInfo.lastAttrsVal[attrName]) //skip, change by render\r\n            return ;\r\n        \r\n        if(!newVal) // attr removed\r\n        {\r\n            delete nodeInfo.attrs[attrName];\r\n            this.setupElementDirectives(element, nodeInfo);\r\n            return ;\r\n        }\r\n        \r\n        if(attrInfo.srcVal != newVal) //attr really changed\r\n        {\r\n            attrInfo = this.updateAttribute(attrInfo, newVal);\r\n            if(!attrInfo)\r\n                delete nodeInfo.attrs[attrName];\r\n            \r\n            this.setupElementDirectives(element, nodeInfo);\r\n            return ;\r\n        }\r\n    }\r\n    \r\n    private setupElement(element: Element)\r\n    {\r\n        const info: NodeElementInfo = this.getNodeInfo(element) as NodeElementInfo || {\r\n            id: 'LDE'+(nextId++),\r\n            srcElement: element,\r\n            // placeholderComment: null,\r\n            attrs: {},\r\n            directives: [],\r\n            disableChildNodes: false,\r\n        };\r\n        \r\n        this.setupElementAttributes(element, info);\r\n        this.setupElementDirectives(element, info);\r\n        // element.setAttribute(\"ld-track-id\", info.id);\r\n        \r\n        if(Object.keys(info.attrs).length == 0 && info.directives.length == 0)\r\n        {\r\n            this.setNodeInfo(element, null);\r\n            return ;\r\n        }\r\n        \r\n        info.render = this.renderElement.bind(this);\r\n        this.setNodeInfo(element, info);\r\n    }\r\n    private setupElementAttributes(element: Element, info: NodeElementInfo)\r\n    {\r\n        const attrs = element.attributes;\r\n        for(let i=attrs.length-1; i>=0; --i)\r\n        {\r\n            const attr = attrs[i];\r\n            // if(info.attrs[attr.name] && info.attrs[attr.name].srcVal == attr.value)\r\n            //     continue;\r\n            \r\n            const attrInfo = this.createAttribute(attr.value);\r\n            // console.log(\"initElement attribute:\", attr, attrInfo);\r\n            if(attrInfo)\r\n                info.attrs[attr.name] = attrInfo;\r\n            else\r\n                delete info.attrs[attr.name];\r\n        }\r\n    }\r\n    private createAttribute(attrVal: string) : AttrInfo\r\n    {\r\n        const parseResult = Parser.parseText(attrVal);\r\n        if(!Parser.hasTextExpress(parseResult))\r\n            return null;\r\n        \r\n        const exec = parseResult.exec;\r\n        const info = {\r\n            srcVal: attrVal,\r\n            lastVal: attrVal,\r\n            paths: parseResult.paths,\r\n            exec: function(data) { return info.lastVal = exec(data); },\r\n            directive: null,\r\n        };\r\n        \r\n        return info;\r\n    }\r\n    private updateAttribute(info: AttrInfo, attrVal)\r\n    {\r\n        const parseResult = Parser.parseText(attrVal);\r\n        if(!Parser.hasTextExpress(parseResult))\r\n            return null;\r\n        \r\n        const exec = parseResult.exec;\r\n        info.exec = exec;\r\n        info.srcVal = attrVal;\r\n        \r\n        return info;\r\n    }\r\n    private setupElementDirectives(element: Element, info: NodeElementInfo)\r\n    {\r\n        info.directives = [];\r\n        \r\n        for(const config of this.elementDirectivesConfig)\r\n        {\r\n            config.setup(this, element, info, config);\r\n        }\r\n    }\r\n    private renderElement(element: Element)\r\n    {\r\n        const nodeInfo = this.getNodeInfo(element) as NodeElementInfo;\r\n        // console.log(\"renderElement:\", placeholder, this.isLiveNode(placeholder), elementInfo);\r\n        if(! nodeInfo)\r\n        {\r\n            this.renderChildNodes(element);\r\n            return ;\r\n        }\r\n        \r\n        const exists: Node[] = [element];\r\n        let nextNode = element.nextSibling;\r\n        while(nextNode)\r\n        {\r\n            const nextInfo = this.getNodeInfo(nextNode);\r\n            if(nextInfo != nodeInfo)\r\n                break;\r\n            \r\n            exists.push(nextNode);\r\n            nextNode = nextNode.nextSibling;\r\n        }\r\n        // console.log(\"renderElement exists:\", placeholder, exists, exists.map(n => n.parentNode));\r\n        \r\n        const renderInfo: ElementRenderInfo = {\r\n            lastAttrsVal: {},\r\n            ...this.getRenderInfo(element) as ElementRenderInfo,\r\n            nodeInfo: nodeInfo,\r\n            exists,\r\n        };\r\n        \r\n        const srcElement = element.nodeType==1 ? element : nodeInfo.srcElement;\r\n        const renderElements = this.processElementDirectiveRender(srcElement, renderInfo, 0);\r\n        // console.log(\"renderElement renderElements:\", placeholder, placeholder.parentNode, element, renderElements, renderInfo);\r\n        if(renderElements.length == 0)\r\n        {\r\n            // console.log(\"renderElement renderElements remove:\", exists.length, element.parentNode, element);\r\n            const placeholderComment = this.getPlaceholderComment(nodeInfo);\r\n            insertAfter(element, placeholderComment);\r\n            // console.log(\"renderElement placeholderComment:\", placeholder, placeholder.parentNode, placeholderComment, exists);\r\n            for(const ele of exists)\r\n            {\r\n                // console.log(\">>>>>>>>>>>>>>>>>>>>>>>> removeNode:\", placeholder, ele != placeholderComment, ele.parentNode, ele);\r\n                if(ele != placeholderComment)\r\n                    removeNode(ele);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            let prev = element;\r\n            for(const ele of renderElements)\r\n            {\r\n                insertAfter(prev, ele);\r\n                prev = ele;\r\n            }\r\n            \r\n            for(const ele of exists)\r\n            {\r\n                if(renderElements.indexOf(ele as Element) < 0)\r\n                    removeNode(ele);\r\n            }\r\n        }\r\n    }\r\n    private processElementDirectiveRender(element: Element, renderInfo: ElementRenderInfo, directiveIndex: number) : Element[]\r\n    {\r\n        const directives = renderInfo.nodeInfo.directives;\r\n        \r\n        if(directiveIndex < directives.length)\r\n        {\r\n            return directives[directiveIndex].render(\r\n                element,\r\n                renderInfo, \r\n                (ele: Element, ri: ElementRenderInfo) => this.processElementDirectiveRender(ele, ri, directiveIndex+1)\r\n            );\r\n        }\r\n        \r\n        this.setRenderInfo(element, renderInfo);\r\n        return [element];\r\n    }\r\n    public isPlaceholder(node: Node) : boolean\r\n    {\r\n        if(node.nodeType != 8) //8: Node.COMMENT_NODE\r\n            return false;\r\n        \r\n        const info = this.getRenderInfo(node) as PlaceholderRenderInfo;\r\n        return !!info && !!info.isPlaceholder;\r\n    }\r\n    private getPlaceholderComment(info: NodeElementInfo) : Comment\r\n    {\r\n        const placeholderComment = this.doc.createComment(\"_LiveDomId=\"+info.id);\r\n        const renderInfo: PlaceholderRenderInfo = {nodeInfo: info, isPlaceholder: true};\r\n        this.setNodeInfo(placeholderComment, info);\r\n        this.setRenderInfo(placeholderComment, renderInfo);\r\n        return placeholderComment;\r\n    }\r\n    public renderChildNodes(parentNode: Node) //TODO move to DirectiveElementChildNodes\r\n    {\r\n        const t = nextId ++;\r\n        const nodes = [];\r\n        const l = parentNode.childNodes.length;\r\n        for(let i=0; i<l; ++i)\r\n            nodes.push(parentNode.childNodes[i]);\r\n        \r\n        for(let i=0; i<l; ++i)\r\n        {\r\n            const node = nodes[i];\r\n            const info = this.getNodeInfo(node);\r\n            if(!info)\r\n            {\r\n                if(node.nodeType == 1) // 1: Node.ELEMENT_NODE\r\n                    this.renderChildNodes(node);\r\n                continue;\r\n            }\r\n            \r\n            if(info._t == t)\r\n                continue;\r\n            \r\n            info.render(node);\r\n            info._t = t;\r\n        }\r\n    }\r\n    \r\n    private setupText(text: Text)\r\n    {\r\n        const parseResult = Parser.parseText(text.data);\r\n        // console.log(\"buildNode parseText:\", parseResult, parseResult.exec({}));\r\n        if(!Parser.hasTextExpress(parseResult))\r\n            return ;\r\n        \r\n        const info: NodeTextInfo = {\r\n            id: 'LDT'+(nextId++),\r\n        };\r\n        const textExec = parseResult.exec;\r\n        \r\n        // console.log(\"buildNode:\", info, text);\r\n        info.render = (node: Text) =>\r\n        {\r\n            node.data = textExec(this.dataManager.data);\r\n        }\r\n        this.setNodeInfo(text, info);\r\n        // info.render(text);\r\n    }\r\n    \r\n    public cloneNode<N extends Node>(src: N): N\r\n    {\r\n        const des = src.cloneNode(true);\r\n        this.cloneNodesInfo([src], [des]);\r\n        return des as N;\r\n    }\r\n    private cloneNodesInfo(srcNodes: Node[]|NodeListOf<ChildNode>, desNodes: Node[]|NodeListOf<ChildNode>)\r\n    {\r\n        for(let i=0, l=srcNodes.length; i < l; ++i)\r\n        {\r\n            desNodes[i][propNodeInfo] = srcNodes[i][propNodeInfo];\r\n            \r\n            if(srcNodes[i].nodeType == 1) // 1: Node.ELEMENT_NODE\r\n                this.cloneNodesInfo(srcNodes[i].childNodes, desNodes[i].childNodes);\r\n        }\r\n    }\r\n    \r\n    private setNodeInfo(node: Node, info: NodeInfo)\r\n    {\r\n        //weak map ?\r\n        //prop map ?\r\n        node[propNodeInfo] = info;\r\n    }\r\n    public getNodeInfo(node: Node) : NodeInfo\r\n    {\r\n        return node[propNodeInfo] || null;\r\n    }\r\n    private hasNodeInfo(node: Node) : boolean\r\n    {\r\n        return !!node[propNodeInfo];\r\n    }\r\n    \r\n    private setRenderInfo(node: Node, info: RenderInfo)\r\n    {\r\n        //weak map ?\r\n        //prop map ?\r\n        node[propRenderInfo] = info;\r\n    }\r\n    public getRenderInfo(node: Node) : RenderInfo\r\n    {\r\n        return node[propRenderInfo] || null;\r\n    }\r\n    private hasRenderInfo(node: Node) : boolean\r\n    {\r\n        return !!node[propRenderInfo];\r\n    }\r\n    \r\n    private isLiveNode(node: Node) : boolean\r\n    {\r\n        return propNodeInfo in node; //TODO use renderInfo\r\n    }\r\n}\r\n\r\ninterface PlaceholderRenderInfo extends RenderInfo\r\n{\r\n    isPlaceholder: boolean;\r\n}\r\n\r\nfunction removeNode(node: Node)\r\n{\r\n    if(node.parentNode)\r\n        node.parentNode.removeChild(node);\r\n}\r\n\r\nfunction insertAfter(before: Node, node: Node)\r\n{\r\n    // console.log(\"insertAfter:\", before, node, before==node, !!before.nextSibling, !!node.parentNode);\r\n    if(before == node)\r\n        return ;\r\n    else if(before.nextSibling)\r\n        before.parentNode.insertBefore(node, before.nextSibling);\r\n    else\r\n        before.parentNode.appendChild(node);\r\n}\r\n\r\nfunction wait(ms: number) : Promise<void>\r\n{\r\n    return new Promise(function(resolve)\r\n    {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\r\n","import { DataPaths, TypeData } from \"./DataManager\";\r\n\r\nexport type TextFunction<R=any> = (data: TypeData) => R;\r\n\r\ninterface ParseTextResult\r\n{\r\n    // vars: string[];\r\n    parts: (string|TextFunction)[];\r\n    paths: DataPaths;\r\n    exec(data: TypeData);\r\n}\r\n\r\nexport class Parser\r\n{\r\n    public static parseText(text: string) : ParseTextResult\r\n    {\r\n        const expressionRegex = /\\$\\{\\s*([a-zA-z_]\\w*(\\.\\w+)*)\\s*\\}/g;\r\n        // console.log(\"parseText:\", text.length, text.match(expressionRegex));\r\n        const parts: (string|TextFunction)[] = [];\r\n        const paths: DataPaths = {};\r\n        let match: RegExpExecArray = null;\r\n        let lastIndex = 0;\r\n        \r\n        while(match = expressionRegex.exec(text))\r\n        {\r\n            if(lastIndex < match.index)\r\n                parts.push(text.substring(lastIndex, match.index));\r\n            \r\n            // console.log(\"parseText result:\", result, expressionRegex.lastIndex);\r\n            const names = match[1].split(/\\./g);\r\n            paths[match[1]] = names;\r\n            parts.push(buildTextFunction(names));\r\n            \r\n            lastIndex = expressionRegex.lastIndex;\r\n        }\r\n        \r\n        if(lastIndex < text.length)\r\n            parts.push(text.substring(lastIndex, text.length));\r\n        // console.log(\"parseText lastIndex:\", expressionRegex.lastIndex, parts);\r\n        \r\n        return {\r\n            parts,\r\n            paths,\r\n            exec: buildParseResultRenderer(parts),\r\n        }; \r\n    }\r\n\r\n    public static hasTextExpress(result: ParseTextResult)\r\n    {\r\n        if(result.parts.length > 1)\r\n            return true;\r\n        \r\n        return result.parts.length == 1 && typeof(result.parts[0]) != \"string\";\r\n    }\r\n}\r\n\r\n\r\n// function getWatchVars(info: ParseTextExpressionInfo): string[]\r\n// {\r\n//     // return [info.var.replace(/\\s*\\.\\s*/g, \".\")];\r\n//     return info.var.split(/\\s*\\.\\s*/, 1).slice(0, 1);\r\n// }\r\n\r\nfunction buildTextFunction(names: string[]) : TextFunction\r\n{\r\n    let lastNamePath = \"\";\r\n    let namesPath = names.map((name) =>\r\n    {\r\n        lastNamePath = lastNamePath + \".\" + name;\r\n        return lastNamePath.substring(1);\r\n    });\r\n    \r\n    // let body = \"return data\" + names.map(name => '[\"'+name+'\"]').join(\"\") + \";\";\r\n    let body = `var ${names[0]}=data.${names[0]}; `\r\n            + `return (${namesPath.map(p => `${p}!==null&&${p}!==void 0`).join(\" && \")}) ? ${names.join(\".\")} : null;`;\r\n    \r\n    // console.log(\"buildTextRenderer:\", names, namesPath, body);\r\n    return new Function(\"data\", body) as TextFunction;\r\n}\r\n\r\nfunction buildParseResultRenderer(parts: (string|TextFunction)[])\r\n{\r\n    if(parts.length == 1 && typeof(parts[0]) == \"function\")\r\n    {\r\n        return parts[0];\r\n    }\r\n    \r\n    if(parts.length == 1 && typeof(parts[0]) == \"string\")\r\n    {\r\n        const text = parts[0];\r\n        return function() { return text; };\r\n    }\r\n    \r\n    return function(data: TypeData)\r\n    {\r\n        const results: string[] = [];\r\n        for(const p of parts)\r\n        {\r\n            if(typeof(p) == \"string\")\r\n                results.push(p);\r\n            else\r\n                results.push(p(data));\r\n        }\r\n        \r\n        // console.log(\"textNodeRenderer results:\", results, data);\r\n        return results.join(\"\");\r\n    };\r\n}\r\n\r\n\r\n\r\n","import LiveDom from \"./LiveDom\";\r\n\r\n// console.log(\">>>>>>>>>>>>> LiveDom:\", LiveDom);\r\n\r\n// export function testLiveDom()\r\n// {\r\n//     console.log(\">>>>>>>>>>>>> testLiveDom:\", LiveDom);\r\n    \r\n// }\r\n\r\n// window[\"LiveDom\"] = LiveDom;\r\n\r\nexport = LiveDom;\r\n"]}